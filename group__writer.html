<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MPack: Write API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-mpack-css.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MPack<span id="projectnumber">&#160;1.1.1</span>
   </div>
   <div id="projectbrief">A C encoding/decoding library for the MessagePack serialization format.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle"><div class="title">Write API</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p >The MPack Write API encodes structured data of a fixed (hardcoded) schema to MessagePack. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga34786576628c2f814b5d109daf0af7d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga34786576628c2f814b5d109daf0af7d1">MPACK_WRITER_MINIMUM_BUFFER_SIZE</a>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:ga34786576628c2f814b5d109daf0af7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum buffer size for a writer with a flush function.  <a href="group__writer.html#ga34786576628c2f814b5d109daf0af7d1">More...</a><br /></td></tr>
<tr class="separator:ga34786576628c2f814b5d109daf0af7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga65d410be0305a59ec15cfe700f8b036a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga65d410be0305a59ec15cfe700f8b036a">mpack_writer_error_t</a>) (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td></tr>
<tr class="memdesc:ga65d410be0305a59ec15cfe700f8b036a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error handler function to be called when an error is flagged on the writer.  <a href="group__writer.html#ga65d410be0305a59ec15cfe700f8b036a">More...</a><br /></td></tr>
<tr class="separator:ga65d410be0305a59ec15cfe700f8b036a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5749babfacaa707cbaff06bcbc790a5"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gad5749babfacaa707cbaff06bcbc790a5">mpack_writer_flush_t</a>) (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *buffer, size_t count)</td></tr>
<tr class="memdesc:gad5749babfacaa707cbaff06bcbc790a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MPack writer's flush function to flush the buffer to the output stream.  <a href="group__writer.html#gad5749babfacaa707cbaff06bcbc790a5">More...</a><br /></td></tr>
<tr class="separator:gad5749babfacaa707cbaff06bcbc790a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdb207d4ba6a6ae47efa5ede13436f31"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a></td></tr>
<tr class="memdesc:gabdb207d4ba6a6ae47efa5ede13436f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffered MessagePack encoder.  <a href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">More...</a><br /></td></tr>
<tr class="separator:gabdb207d4ba6a6ae47efa5ede13436f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97ccab59b332d882d386c10b241eb888"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga97ccab59b332d882d386c10b241eb888">mpack_writer_teardown_t</a>) (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="memdesc:ga97ccab59b332d882d386c10b241eb888"><td class="mdescLeft">&#160;</td><td class="mdescRight">A teardown function to be called when the writer is destroyed.  <a href="group__writer.html#ga97ccab59b332d882d386c10b241eb888">More...</a><br /></td></tr>
<tr class="separator:ga97ccab59b332d882d386c10b241eb888"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Lifecycle Functions</h2></td></tr>
<tr class="memitem:gabf46d5fd103d44d03c412cb7bb52e2d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gabf46d5fd103d44d03c412cb7bb52e2d0">mpack_writer_init</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, char *buffer, size_t size)</td></tr>
<tr class="memdesc:gabf46d5fd103d44d03c412cb7bb52e2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an MPack writer with the given buffer.  <a href="group__writer.html#gabf46d5fd103d44d03c412cb7bb52e2d0">More...</a><br /></td></tr>
<tr class="separator:gabf46d5fd103d44d03c412cb7bb52e2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aa3b265fb5ece9c4cba0f2b1bfbdb53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga0aa3b265fb5ece9c4cba0f2b1bfbdb53">mpack_writer_init_growable</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, char **data, size_t *size)</td></tr>
<tr class="memdesc:ga0aa3b265fb5ece9c4cba0f2b1bfbdb53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an MPack writer using a growable buffer.  <a href="group__writer.html#ga0aa3b265fb5ece9c4cba0f2b1bfbdb53">More...</a><br /></td></tr>
<tr class="separator:ga0aa3b265fb5ece9c4cba0f2b1bfbdb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3c8d9ebe78513a17a38af28f387d169"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gab3c8d9ebe78513a17a38af28f387d169">mpack_writer_init_error</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td></tr>
<tr class="memdesc:gab3c8d9ebe78513a17a38af28f387d169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an MPack writer directly into an error state.  <a href="group__writer.html#gab3c8d9ebe78513a17a38af28f387d169">More...</a><br /></td></tr>
<tr class="separator:gab3c8d9ebe78513a17a38af28f387d169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80c2f57160ec9e0efe02f2b3820a8661"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga80c2f57160ec9e0efe02f2b3820a8661">mpack_writer_init_filename</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *filename)</td></tr>
<tr class="memdesc:ga80c2f57160ec9e0efe02f2b3820a8661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an MPack writer that writes to a file.  <a href="group__writer.html#ga80c2f57160ec9e0efe02f2b3820a8661">More...</a><br /></td></tr>
<tr class="separator:ga80c2f57160ec9e0efe02f2b3820a8661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb05fb381c28a36b8917a1697e5ab611"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gafb05fb381c28a36b8917a1697e5ab611">mpack_writer_init_file</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *filename)</td></tr>
<tr class="memdesc:gafb05fb381c28a36b8917a1697e5ab611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated.  <a href="group__writer.html#gafb05fb381c28a36b8917a1697e5ab611">More...</a><br /></td></tr>
<tr class="separator:gafb05fb381c28a36b8917a1697e5ab611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe9a212641a4edd010ccdd9ecf888485"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gabe9a212641a4edd010ccdd9ecf888485">mpack_writer_init_stdfile</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, FILE *stdfile, bool close_when_done)</td></tr>
<tr class="memdesc:gabe9a212641a4edd010ccdd9ecf888485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an MPack writer that writes to a libc FILE.  <a href="group__writer.html#gabe9a212641a4edd010ccdd9ecf888485">More...</a><br /></td></tr>
<tr class="separator:gabe9a212641a4edd010ccdd9ecf888485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cf5a2d9b687d94f637a36123ef7cec0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga1cf5a2d9b687d94f637a36123ef7cec0">mpack_writer_destroy</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="memdesc:ga1cf5a2d9b687d94f637a36123ef7cec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up the MPack writer, flushing and closing the underlying stream, if any.  <a href="group__writer.html#ga1cf5a2d9b687d94f637a36123ef7cec0">More...</a><br /></td></tr>
<tr class="separator:ga1cf5a2d9b687d94f637a36123ef7cec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Configuration</h2></td></tr>
<tr class="memitem:ga17f828f0b8e560dfdc7cc635f462f6f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga17f828f0b8e560dfdc7cc635f462f6f7">mpack_writer_set_version</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, <a class="el" href="group__common.html#gaba84f7d6b203a1f51f2a3e10c80318e2">mpack_version_t</a> version)</td></tr>
<tr class="memdesc:ga17f828f0b8e560dfdc7cc635f462f6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the version of the MessagePack spec that will be generated.  <a href="group__writer.html#ga17f828f0b8e560dfdc7cc635f462f6f7">More...</a><br /></td></tr>
<tr class="separator:ga17f828f0b8e560dfdc7cc635f462f6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64b403d4370a99e063052f7b9188ad0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga64b403d4370a99e063052f7b9188ad0b">mpack_writer_set_context</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, void *context)</td></tr>
<tr class="memdesc:ga64b403d4370a99e063052f7b9188ad0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the custom pointer to pass to the writer callbacks, such as flush or teardown.  <a href="group__writer.html#ga64b403d4370a99e063052f7b9188ad0b">More...</a><br /></td></tr>
<tr class="separator:ga64b403d4370a99e063052f7b9188ad0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e559b7e5bf12da56065bcc28fc09120"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga8e559b7e5bf12da56065bcc28fc09120">mpack_writer_context</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="memdesc:ga8e559b7e5bf12da56065bcc28fc09120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the custom context for writer callbacks.  <a href="group__writer.html#ga8e559b7e5bf12da56065bcc28fc09120">More...</a><br /></td></tr>
<tr class="separator:ga8e559b7e5bf12da56065bcc28fc09120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1337e25984152198814d94b8ddf2e1e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga1337e25984152198814d94b8ddf2e1e1">mpack_writer_set_flush</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, <a class="el" href="group__writer.html#gad5749babfacaa707cbaff06bcbc790a5">mpack_writer_flush_t</a> flush)</td></tr>
<tr class="memdesc:ga1337e25984152198814d94b8ddf2e1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the flush function to write out the data when the buffer is full.  <a href="group__writer.html#ga1337e25984152198814d94b8ddf2e1e1">More...</a><br /></td></tr>
<tr class="separator:ga1337e25984152198814d94b8ddf2e1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b406a46d698bfb2e70cefeea5033d9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga8b406a46d698bfb2e70cefeea5033d9e">mpack_writer_set_error_handler</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, <a class="el" href="group__writer.html#ga65d410be0305a59ec15cfe700f8b036a">mpack_writer_error_t</a> error_fn)</td></tr>
<tr class="memdesc:ga8b406a46d698bfb2e70cefeea5033d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the error function to call when an error is flagged on the writer.  <a href="group__writer.html#ga8b406a46d698bfb2e70cefeea5033d9e">More...</a><br /></td></tr>
<tr class="separator:ga8b406a46d698bfb2e70cefeea5033d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec0ca26b9eeba93fa07cd82eff32d526"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gaec0ca26b9eeba93fa07cd82eff32d526">mpack_writer_set_teardown</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, <a class="el" href="group__writer.html#ga97ccab59b332d882d386c10b241eb888">mpack_writer_teardown_t</a> teardown)</td></tr>
<tr class="memdesc:gaec0ca26b9eeba93fa07cd82eff32d526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the teardown function to call when the writer is destroyed.  <a href="group__writer.html#gaec0ca26b9eeba93fa07cd82eff32d526">More...</a><br /></td></tr>
<tr class="separator:gaec0ca26b9eeba93fa07cd82eff32d526"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Core Writer Functions</h2></td></tr>
<tr class="memitem:ga0e8649525969ae318bf0f125d8b55f50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga0e8649525969ae318bf0f125d8b55f50">mpack_writer_flush_message</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="memdesc:ga0e8649525969ae318bf0f125d8b55f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes any buffered data to the underlying stream.  <a href="group__writer.html#ga0e8649525969ae318bf0f125d8b55f50">More...</a><br /></td></tr>
<tr class="separator:ga0e8649525969ae318bf0f125d8b55f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52d9c903ac8d34d9b789551d83f09a87"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga52d9c903ac8d34d9b789551d83f09a87">mpack_writer_buffer_used</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="memdesc:ga52d9c903ac8d34d9b789551d83f09a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes currently stored in the buffer.  <a href="group__writer.html#ga52d9c903ac8d34d9b789551d83f09a87">More...</a><br /></td></tr>
<tr class="separator:ga52d9c903ac8d34d9b789551d83f09a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga794ca9b6b8191b6615df5f4762e44727"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga794ca9b6b8191b6615df5f4762e44727">mpack_writer_buffer_left</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="memdesc:ga794ca9b6b8191b6615df5f4762e44727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of space left in the buffer.  <a href="group__writer.html#ga794ca9b6b8191b6615df5f4762e44727">More...</a><br /></td></tr>
<tr class="separator:ga794ca9b6b8191b6615df5f4762e44727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fb507f2ed3ba3dd1eb9a339d2fcaeb5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga7fb507f2ed3ba3dd1eb9a339d2fcaeb5">mpack_writer_buffer_size</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="memdesc:ga7fb507f2ed3ba3dd1eb9a339d2fcaeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (current) size of the buffer.  <a href="group__writer.html#ga7fb507f2ed3ba3dd1eb9a339d2fcaeb5">More...</a><br /></td></tr>
<tr class="separator:ga7fb507f2ed3ba3dd1eb9a339d2fcaeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf90e598304c7e8a423c534a5d554075e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gaf90e598304c7e8a423c534a5d554075e">mpack_writer_flag_error</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td></tr>
<tr class="memdesc:gaf90e598304c7e8a423c534a5d554075e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places the writer in the given error state, calling the error callback if one is set.  <a href="group__writer.html#gaf90e598304c7e8a423c534a5d554075e">More...</a><br /></td></tr>
<tr class="separator:gaf90e598304c7e8a423c534a5d554075e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3adcd5dc4478fbd25b5b48a1c93f0597"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga3adcd5dc4478fbd25b5b48a1c93f0597">mpack_writer_error</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="memdesc:ga3adcd5dc4478fbd25b5b48a1c93f0597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the error state of the MPack writer.  <a href="group__writer.html#ga3adcd5dc4478fbd25b5b48a1c93f0597">More...</a><br /></td></tr>
<tr class="separator:ga3adcd5dc4478fbd25b5b48a1c93f0597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17155afc35912817c13802d502f14e80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga17155afc35912817c13802d502f14e80">mpack_write_tag</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, <a class="el" href="group__common.html#ga008da69ac6b5582a893f2d2ffd37f4ac">mpack_tag_t</a> tag)</td></tr>
<tr class="memdesc:ga17155afc35912817c13802d502f14e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a MessagePack object header (an MPack Tag.)  <a href="group__writer.html#ga17155afc35912817c13802d502f14e80">More...</a><br /></td></tr>
<tr class="separator:ga17155afc35912817c13802d502f14e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Integers</h2></td></tr>
<tr class="memitem:ga4776a1693cf3d69f628ea0306b3867ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga4776a1693cf3d69f628ea0306b3867ac">mpack_write_i8</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, int8_t value)</td></tr>
<tr class="memdesc:ga4776a1693cf3d69f628ea0306b3867ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an 8-bit integer in the most efficient packing available.  <a href="group__writer.html#ga4776a1693cf3d69f628ea0306b3867ac">More...</a><br /></td></tr>
<tr class="separator:ga4776a1693cf3d69f628ea0306b3867ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf30d21cb4c7c77c4ef99f9f9a1a8791"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gabf30d21cb4c7c77c4ef99f9f9a1a8791">mpack_write_i16</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, int16_t value)</td></tr>
<tr class="memdesc:gabf30d21cb4c7c77c4ef99f9f9a1a8791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a 16-bit integer in the most efficient packing available.  <a href="group__writer.html#gabf30d21cb4c7c77c4ef99f9f9a1a8791">More...</a><br /></td></tr>
<tr class="separator:gabf30d21cb4c7c77c4ef99f9f9a1a8791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a437633c12478dc827977dc7cf6eb66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga3a437633c12478dc827977dc7cf6eb66">mpack_write_i32</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, int32_t value)</td></tr>
<tr class="memdesc:ga3a437633c12478dc827977dc7cf6eb66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a 32-bit integer in the most efficient packing available.  <a href="group__writer.html#ga3a437633c12478dc827977dc7cf6eb66">More...</a><br /></td></tr>
<tr class="separator:ga3a437633c12478dc827977dc7cf6eb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8fcdb4f4ff97c3197a8bb809b88a167"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gab8fcdb4f4ff97c3197a8bb809b88a167">mpack_write_i64</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, int64_t value)</td></tr>
<tr class="memdesc:gab8fcdb4f4ff97c3197a8bb809b88a167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a 64-bit integer in the most efficient packing available.  <a href="group__writer.html#gab8fcdb4f4ff97c3197a8bb809b88a167">More...</a><br /></td></tr>
<tr class="separator:gab8fcdb4f4ff97c3197a8bb809b88a167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf4d702ebb08c040512f141ed46395c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gadf4d702ebb08c040512f141ed46395c7">mpack_write_int</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, int64_t value)</td></tr>
<tr class="memdesc:gadf4d702ebb08c040512f141ed46395c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an integer in the most efficient packing available.  <a href="group__writer.html#gadf4d702ebb08c040512f141ed46395c7">More...</a><br /></td></tr>
<tr class="separator:gadf4d702ebb08c040512f141ed46395c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga573a41209a4b9125ee28c19cddef309a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga573a41209a4b9125ee28c19cddef309a">mpack_write_u8</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, uint8_t value)</td></tr>
<tr class="memdesc:ga573a41209a4b9125ee28c19cddef309a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an 8-bit unsigned integer in the most efficient packing available.  <a href="group__writer.html#ga573a41209a4b9125ee28c19cddef309a">More...</a><br /></td></tr>
<tr class="separator:ga573a41209a4b9125ee28c19cddef309a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfd74ba7f9f7fddb04d5b4fc5775342d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gabfd74ba7f9f7fddb04d5b4fc5775342d">mpack_write_u16</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, uint16_t value)</td></tr>
<tr class="memdesc:gabfd74ba7f9f7fddb04d5b4fc5775342d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an 16-bit unsigned integer in the most efficient packing available.  <a href="group__writer.html#gabfd74ba7f9f7fddb04d5b4fc5775342d">More...</a><br /></td></tr>
<tr class="separator:gabfd74ba7f9f7fddb04d5b4fc5775342d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c20b876be3a17487a6de49cf5a29b57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga6c20b876be3a17487a6de49cf5a29b57">mpack_write_u32</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, uint32_t value)</td></tr>
<tr class="memdesc:ga6c20b876be3a17487a6de49cf5a29b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an 32-bit unsigned integer in the most efficient packing available.  <a href="group__writer.html#ga6c20b876be3a17487a6de49cf5a29b57">More...</a><br /></td></tr>
<tr class="separator:ga6c20b876be3a17487a6de49cf5a29b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41d333e6d813655b8054c5ec53832c7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga41d333e6d813655b8054c5ec53832c7c">mpack_write_u64</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, uint64_t value)</td></tr>
<tr class="memdesc:ga41d333e6d813655b8054c5ec53832c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an 64-bit unsigned integer in the most efficient packing available.  <a href="group__writer.html#ga41d333e6d813655b8054c5ec53832c7c">More...</a><br /></td></tr>
<tr class="separator:ga41d333e6d813655b8054c5ec53832c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2e3cd22bad53b31bed85d7b46d135c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gab2e3cd22bad53b31bed85d7b46d135c9">mpack_write_uint</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, uint64_t value)</td></tr>
<tr class="memdesc:gab2e3cd22bad53b31bed85d7b46d135c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an unsigned integer in the most efficient packing available.  <a href="group__writer.html#gab2e3cd22bad53b31bed85d7b46d135c9">More...</a><br /></td></tr>
<tr class="separator:gab2e3cd22bad53b31bed85d7b46d135c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Other Basic Types</h2></td></tr>
<tr class="memitem:ga285ce9cc180f3b623fbf07c67e2f9ca3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga285ce9cc180f3b623fbf07c67e2f9ca3">mpack_write_float</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, float value)</td></tr>
<tr class="memdesc:ga285ce9cc180f3b623fbf07c67e2f9ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a float.  <a href="group__writer.html#ga285ce9cc180f3b623fbf07c67e2f9ca3">More...</a><br /></td></tr>
<tr class="separator:ga285ce9cc180f3b623fbf07c67e2f9ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bc0c6c6416b9d808be718b41681fd25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga2bc0c6c6416b9d808be718b41681fd25">mpack_write_double</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, double value)</td></tr>
<tr class="memdesc:ga2bc0c6c6416b9d808be718b41681fd25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a double.  <a href="group__writer.html#ga2bc0c6c6416b9d808be718b41681fd25">More...</a><br /></td></tr>
<tr class="separator:ga2bc0c6c6416b9d808be718b41681fd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d8fa89f571534f5ddbdf81f5bbd5de8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga5d8fa89f571534f5ddbdf81f5bbd5de8">mpack_write_bool</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, bool value)</td></tr>
<tr class="memdesc:ga5d8fa89f571534f5ddbdf81f5bbd5de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a boolean.  <a href="group__writer.html#ga5d8fa89f571534f5ddbdf81f5bbd5de8">More...</a><br /></td></tr>
<tr class="separator:ga5d8fa89f571534f5ddbdf81f5bbd5de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d9f083fd8556ba30f93d4ad139d0dad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga5d9f083fd8556ba30f93d4ad139d0dad">mpack_write_true</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="memdesc:ga5d9f083fd8556ba30f93d4ad139d0dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a boolean with value true.  <a href="group__writer.html#ga5d9f083fd8556ba30f93d4ad139d0dad">More...</a><br /></td></tr>
<tr class="separator:ga5d9f083fd8556ba30f93d4ad139d0dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab05b274195191e6e98c4a8d0ec730f63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gab05b274195191e6e98c4a8d0ec730f63">mpack_write_false</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="memdesc:gab05b274195191e6e98c4a8d0ec730f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a boolean with value false.  <a href="group__writer.html#gab05b274195191e6e98c4a8d0ec730f63">More...</a><br /></td></tr>
<tr class="separator:gab05b274195191e6e98c4a8d0ec730f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea8d479af0d05cff5194502362ae82a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gaea8d479af0d05cff5194502362ae82a5">mpack_write_nil</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="memdesc:gaea8d479af0d05cff5194502362ae82a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a nil.  <a href="group__writer.html#gaea8d479af0d05cff5194502362ae82a5">More...</a><br /></td></tr>
<tr class="separator:gaea8d479af0d05cff5194502362ae82a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a100199b2dc33b41fd5f99c428048ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga7a100199b2dc33b41fd5f99c428048ac">mpack_write_object_bytes</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *data, size_t bytes)</td></tr>
<tr class="memdesc:ga7a100199b2dc33b41fd5f99c428048ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a pre-encoded messagepack object.  <a href="group__writer.html#ga7a100199b2dc33b41fd5f99c428048ac">More...</a><br /></td></tr>
<tr class="separator:ga7a100199b2dc33b41fd5f99c428048ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f30a610b72615b21e69b7639781901d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga3f30a610b72615b21e69b7639781901d">mpack_write_timestamp</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, int64_t seconds, uint32_t nanoseconds)</td></tr>
<tr class="memdesc:ga3f30a610b72615b21e69b7639781901d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a timestamp.  <a href="group__writer.html#ga3f30a610b72615b21e69b7639781901d">More...</a><br /></td></tr>
<tr class="separator:ga3f30a610b72615b21e69b7639781901d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8fdbdacfa5c2518ed0ea31d44f676e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gad8fdbdacfa5c2518ed0ea31d44f676e4">mpack_write_timestamp_seconds</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, int64_t seconds)</td></tr>
<tr class="memdesc:gad8fdbdacfa5c2518ed0ea31d44f676e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a timestamp with the given number of seconds (and zero nanoseconds).  <a href="group__writer.html#gad8fdbdacfa5c2518ed0ea31d44f676e4">More...</a><br /></td></tr>
<tr class="separator:gad8fdbdacfa5c2518ed0ea31d44f676e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga635ed35d21688d038f5fabfcfeab32a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga635ed35d21688d038f5fabfcfeab32a5">mpack_write_timestamp_struct</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, <a class="el" href="group__common.html#structmpack__timestamp__t">mpack_timestamp_t</a> timestamp)</td></tr>
<tr class="memdesc:ga635ed35d21688d038f5fabfcfeab32a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a timestamp.  <a href="group__writer.html#ga635ed35d21688d038f5fabfcfeab32a5">More...</a><br /></td></tr>
<tr class="separator:ga635ed35d21688d038f5fabfcfeab32a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Map and Array Functions</h2></td></tr>
<tr class="memitem:ga3d2c452b01415f7d86db2ecd1a5aa329"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga3d2c452b01415f7d86db2ecd1a5aa329">mpack_start_array</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, uint32_t count)</td></tr>
<tr class="memdesc:ga3d2c452b01415f7d86db2ecd1a5aa329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an array.  <a href="group__writer.html#ga3d2c452b01415f7d86db2ecd1a5aa329">More...</a><br /></td></tr>
<tr class="separator:ga3d2c452b01415f7d86db2ecd1a5aa329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c54c857ce7f0bdcea9b2df349cbcc61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga5c54c857ce7f0bdcea9b2df349cbcc61">mpack_start_map</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, uint32_t count)</td></tr>
<tr class="memdesc:ga5c54c857ce7f0bdcea9b2df349cbcc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a map.  <a href="group__writer.html#ga5c54c857ce7f0bdcea9b2df349cbcc61">More...</a><br /></td></tr>
<tr class="separator:ga5c54c857ce7f0bdcea9b2df349cbcc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5838a3b81743ecc90f993811a2c6e96"><td class="memItemLeft" align="right" valign="top"><a id="gad5838a3b81743ecc90f993811a2c6e96" name="gad5838a3b81743ecc90f993811a2c6e96"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_builder_compound_push</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="separator:gad5838a3b81743ecc90f993811a2c6e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga001cffbe5a3dd31fb8a4fc125e3fb5fe"><td class="memItemLeft" align="right" valign="top"><a id="ga001cffbe5a3dd31fb8a4fc125e3fb5fe" name="ga001cffbe5a3dd31fb8a4fc125e3fb5fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_builder_compound_pop</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="separator:ga001cffbe5a3dd31fb8a4fc125e3fb5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7ae76ab1bf912e1db537cad69cf5f31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gaa7ae76ab1bf912e1db537cad69cf5f31">mpack_finish_array</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="memdesc:gaa7ae76ab1bf912e1db537cad69cf5f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes writing an array.  <a href="group__writer.html#gaa7ae76ab1bf912e1db537cad69cf5f31">More...</a><br /></td></tr>
<tr class="separator:gaa7ae76ab1bf912e1db537cad69cf5f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf0ab209845e7c9c3df7aa00b0d59a03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gabf0ab209845e7c9c3df7aa00b0d59a03">mpack_finish_map</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="memdesc:gabf0ab209845e7c9c3df7aa00b0d59a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes writing a map.  <a href="group__writer.html#gabf0ab209845e7c9c3df7aa00b0d59a03">More...</a><br /></td></tr>
<tr class="separator:gabf0ab209845e7c9c3df7aa00b0d59a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e10cc90afff17e2c4352c4399be9433"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga5e10cc90afff17e2c4352c4399be9433">mpack_build_array</a> (struct <a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="memdesc:ga5e10cc90afff17e2c4352c4399be9433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts building an array.  <a href="group__writer.html#ga5e10cc90afff17e2c4352c4399be9433">More...</a><br /></td></tr>
<tr class="separator:ga5e10cc90afff17e2c4352c4399be9433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5849bab4afebddae63bb03f5dce5f7d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga5849bab4afebddae63bb03f5dce5f7d8">mpack_build_map</a> (struct <a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="memdesc:ga5849bab4afebddae63bb03f5dce5f7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts building a map.  <a href="group__writer.html#ga5849bab4afebddae63bb03f5dce5f7d8">More...</a><br /></td></tr>
<tr class="separator:ga5849bab4afebddae63bb03f5dce5f7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65e149d035d8de105774ebad2363cac5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga65e149d035d8de105774ebad2363cac5">mpack_complete_array</a> (struct <a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="memdesc:ga65e149d035d8de105774ebad2363cac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes an array being built.  <a href="group__writer.html#ga65e149d035d8de105774ebad2363cac5">More...</a><br /></td></tr>
<tr class="separator:ga65e149d035d8de105774ebad2363cac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10d9f55e0a512d88ede66bbbc543f711"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga10d9f55e0a512d88ede66bbbc543f711">mpack_complete_map</a> (struct <a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="memdesc:ga10d9f55e0a512d88ede66bbbc543f711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes a map being built.  <a href="group__writer.html#ga10d9f55e0a512d88ede66bbbc543f711">More...</a><br /></td></tr>
<tr class="separator:ga10d9f55e0a512d88ede66bbbc543f711"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Data Helpers</h2></td></tr>
<tr class="memitem:gabdd346fe4eb4e1737807932d19a2909f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gabdd346fe4eb4e1737807932d19a2909f">mpack_write_str</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *str, uint32_t length)</td></tr>
<tr class="memdesc:gabdd346fe4eb4e1737807932d19a2909f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a string.  <a href="group__writer.html#gabdd346fe4eb4e1737807932d19a2909f">More...</a><br /></td></tr>
<tr class="separator:gabdd346fe4eb4e1737807932d19a2909f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5284de75985bd7a41997766fdab107f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga5284de75985bd7a41997766fdab107f3">mpack_write_utf8</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *str, uint32_t length)</td></tr>
<tr class="memdesc:ga5284de75985bd7a41997766fdab107f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a string, ensuring that it is valid UTF-8.  <a href="group__writer.html#ga5284de75985bd7a41997766fdab107f3">More...</a><br /></td></tr>
<tr class="separator:ga5284de75985bd7a41997766fdab107f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bd01df04f36b5feb770f449b83995b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga3bd01df04f36b5feb770f449b83995b6">mpack_write_cstr</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *cstr)</td></tr>
<tr class="memdesc:ga3bd01df04f36b5feb770f449b83995b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a null-terminated string.  <a href="group__writer.html#ga3bd01df04f36b5feb770f449b83995b6">More...</a><br /></td></tr>
<tr class="separator:ga3bd01df04f36b5feb770f449b83995b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga661a99e165400758fcd692a2c4dc5cb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga661a99e165400758fcd692a2c4dc5cb6">mpack_write_cstr_or_nil</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *cstr)</td></tr>
<tr class="memdesc:ga661a99e165400758fcd692a2c4dc5cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a null-terminated string, or a nil node if the given cstr pointer is NULL.  <a href="group__writer.html#ga661a99e165400758fcd692a2c4dc5cb6">More...</a><br /></td></tr>
<tr class="separator:ga661a99e165400758fcd692a2c4dc5cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c82b06ba51952b2c8f6508e69f3bcc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga5c82b06ba51952b2c8f6508e69f3bcc5">mpack_write_utf8_cstr</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *cstr)</td></tr>
<tr class="memdesc:ga5c82b06ba51952b2c8f6508e69f3bcc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a null-terminated string, ensuring that it is valid UTF-8.  <a href="group__writer.html#ga5c82b06ba51952b2c8f6508e69f3bcc5">More...</a><br /></td></tr>
<tr class="separator:ga5c82b06ba51952b2c8f6508e69f3bcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ef20cf65309d8deb6a11f6811c6b639"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga2ef20cf65309d8deb6a11f6811c6b639">mpack_write_utf8_cstr_or_nil</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *cstr)</td></tr>
<tr class="memdesc:ga2ef20cf65309d8deb6a11f6811c6b639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a null-terminated string ensuring that it is valid UTF-8, or writes nil if the given cstr pointer is NULL.  <a href="group__writer.html#ga2ef20cf65309d8deb6a11f6811c6b639">More...</a><br /></td></tr>
<tr class="separator:ga2ef20cf65309d8deb6a11f6811c6b639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga379b2db0595d0d0493946290dd827262"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga379b2db0595d0d0493946290dd827262">mpack_write_bin</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *data, uint32_t count)</td></tr>
<tr class="memdesc:ga379b2db0595d0d0493946290dd827262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a binary blob.  <a href="group__writer.html#ga379b2db0595d0d0493946290dd827262">More...</a><br /></td></tr>
<tr class="separator:ga379b2db0595d0d0493946290dd827262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga409f4bb30eb73628490ebf6f445fabc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga409f4bb30eb73628490ebf6f445fabc4">mpack_write_ext</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, int8_t exttype, const char *data, uint32_t count)</td></tr>
<tr class="memdesc:ga409f4bb30eb73628490ebf6f445fabc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an extension type.  <a href="group__writer.html#ga409f4bb30eb73628490ebf6f445fabc4">More...</a><br /></td></tr>
<tr class="separator:ga409f4bb30eb73628490ebf6f445fabc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Chunked Data Functions</h2></td></tr>
<tr class="memitem:ga0f293abb4441a1113b2ed956c3e735ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga0f293abb4441a1113b2ed956c3e735ad">mpack_start_str</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, uint32_t count)</td></tr>
<tr class="memdesc:ga0f293abb4441a1113b2ed956c3e735ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a string.  <a href="group__writer.html#ga0f293abb4441a1113b2ed956c3e735ad">More...</a><br /></td></tr>
<tr class="separator:ga0f293abb4441a1113b2ed956c3e735ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d9d905358fe553360e3071485f75b4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga9d9d905358fe553360e3071485f75b4d">mpack_start_bin</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, uint32_t count)</td></tr>
<tr class="memdesc:ga9d9d905358fe553360e3071485f75b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a binary blob.  <a href="group__writer.html#ga9d9d905358fe553360e3071485f75b4d">More...</a><br /></td></tr>
<tr class="separator:ga9d9d905358fe553360e3071485f75b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9cd08887689641c3d71cea6f536b6f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gab9cd08887689641c3d71cea6f536b6f8">mpack_start_ext</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, int8_t exttype, uint32_t count)</td></tr>
<tr class="memdesc:gab9cd08887689641c3d71cea6f536b6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an extension type.  <a href="group__writer.html#gab9cd08887689641c3d71cea6f536b6f8">More...</a><br /></td></tr>
<tr class="separator:gab9cd08887689641c3d71cea6f536b6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f594d59ddfd2729aa2b3758e1641139"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga7f594d59ddfd2729aa2b3758e1641139">mpack_write_bytes</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *data, size_t count)</td></tr>
<tr class="memdesc:ga7f594d59ddfd2729aa2b3758e1641139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a portion of bytes for a string, binary blob or extension type which was opened by <a class="el" href="group__writer.html#ga17155afc35912817c13802d502f14e80" title="Writes a MessagePack object header (an MPack Tag.)">mpack_write_tag()</a> or one of the mpack_start_*() functions.  <a href="group__writer.html#ga7f594d59ddfd2729aa2b3758e1641139">More...</a><br /></td></tr>
<tr class="separator:ga7f594d59ddfd2729aa2b3758e1641139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44f9dd4d379b70fb9534cf1e359e3d4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga44f9dd4d379b70fb9534cf1e359e3d4a">mpack_finish_str</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="memdesc:ga44f9dd4d379b70fb9534cf1e359e3d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes writing a string.  <a href="group__writer.html#ga44f9dd4d379b70fb9534cf1e359e3d4a">More...</a><br /></td></tr>
<tr class="separator:ga44f9dd4d379b70fb9534cf1e359e3d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaff7b65b611db3cf5b165b7efed0f0f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gaaff7b65b611db3cf5b165b7efed0f0f2">mpack_finish_bin</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="memdesc:gaaff7b65b611db3cf5b165b7efed0f0f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes writing a binary blob.  <a href="group__writer.html#gaaff7b65b611db3cf5b165b7efed0f0f2">More...</a><br /></td></tr>
<tr class="separator:gaaff7b65b611db3cf5b165b7efed0f0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f93f96c951f17bba8cd26a6f50db8e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#ga7f93f96c951f17bba8cd26a6f50db8e2">mpack_finish_ext</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="memdesc:ga7f93f96c951f17bba8cd26a6f50db8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes writing an extended type binary data blob.  <a href="group__writer.html#ga7f93f96c951f17bba8cd26a6f50db8e2">More...</a><br /></td></tr>
<tr class="separator:ga7f93f96c951f17bba8cd26a6f50db8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecfb47a0e86d293ca002f1e11b2edb38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gaecfb47a0e86d293ca002f1e11b2edb38">mpack_finish_type</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, <a class="el" href="group__common.html#ga22f03cf1240d5a917e1b3e7be8ab327e">mpack_type_t</a> type)</td></tr>
<tr class="memdesc:gaecfb47a0e86d293ca002f1e11b2edb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes writing the given compound type.  <a href="group__writer.html#gaecfb47a0e86d293ca002f1e11b2edb38">More...</a><br /></td></tr>
<tr class="separator:gaecfb47a0e86d293ca002f1e11b2edb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">C++ write overloads</h2></td></tr>
<tr class="memitem:gaf5569face88daadd053a1e2ddfa1af03"><td class="memItemLeft" align="right" valign="top"><a id="gaf5569face88daadd053a1e2ddfa1af03" name="gaf5569face88daadd053a1e2ddfa1af03"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, int8_t value)</td></tr>
<tr class="separator:gaf5569face88daadd053a1e2ddfa1af03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecf86283e7e569bcad5dae884c63517c"><td class="memItemLeft" align="right" valign="top"><a id="gaecf86283e7e569bcad5dae884c63517c" name="gaecf86283e7e569bcad5dae884c63517c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, int16_t value)</td></tr>
<tr class="separator:gaecf86283e7e569bcad5dae884c63517c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga303b7c09a9d8e7fbb202f44b6805a75b"><td class="memItemLeft" align="right" valign="top"><a id="ga303b7c09a9d8e7fbb202f44b6805a75b" name="ga303b7c09a9d8e7fbb202f44b6805a75b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, int32_t value)</td></tr>
<tr class="separator:ga303b7c09a9d8e7fbb202f44b6805a75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae9337095e58efcf99e82f6de5f38da2"><td class="memItemLeft" align="right" valign="top"><a id="gaae9337095e58efcf99e82f6de5f38da2" name="gaae9337095e58efcf99e82f6de5f38da2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, int64_t value)</td></tr>
<tr class="separator:gaae9337095e58efcf99e82f6de5f38da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00047a019cd85242109c3cc79811c1d6"><td class="memItemLeft" align="right" valign="top"><a id="ga00047a019cd85242109c3cc79811c1d6" name="ga00047a019cd85242109c3cc79811c1d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, uint8_t value)</td></tr>
<tr class="separator:ga00047a019cd85242109c3cc79811c1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8deac149487a10394947941e0212a9d9"><td class="memItemLeft" align="right" valign="top"><a id="ga8deac149487a10394947941e0212a9d9" name="ga8deac149487a10394947941e0212a9d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, uint16_t value)</td></tr>
<tr class="separator:ga8deac149487a10394947941e0212a9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga103d51b668fd2fc26e72562c33655053"><td class="memItemLeft" align="right" valign="top"><a id="ga103d51b668fd2fc26e72562c33655053" name="ga103d51b668fd2fc26e72562c33655053"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, uint32_t value)</td></tr>
<tr class="separator:ga103d51b668fd2fc26e72562c33655053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4aa00b089c2f44b9a70384ec0d4da08"><td class="memItemLeft" align="right" valign="top"><a id="gad4aa00b089c2f44b9a70384ec0d4da08" name="gad4aa00b089c2f44b9a70384ec0d4da08"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, uint64_t value)</td></tr>
<tr class="separator:gad4aa00b089c2f44b9a70384ec0d4da08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga202b47946dcfa7e1db7a27c36bb4f216"><td class="memItemLeft" align="right" valign="top"><a id="ga202b47946dcfa7e1db7a27c36bb4f216" name="ga202b47946dcfa7e1db7a27c36bb4f216"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, bool value)</td></tr>
<tr class="separator:ga202b47946dcfa7e1db7a27c36bb4f216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae24355234bd59cf6c3e0623b541a9930"><td class="memItemLeft" align="right" valign="top"><a id="gae24355234bd59cf6c3e0623b541a9930" name="gae24355234bd59cf6c3e0623b541a9930"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, float value)</td></tr>
<tr class="separator:gae24355234bd59cf6c3e0623b541a9930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabff2d48de205687bc6ede2aeba7848b6"><td class="memItemLeft" align="right" valign="top"><a id="gabff2d48de205687bc6ede2aeba7848b6" name="gabff2d48de205687bc6ede2aeba7848b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, double value)</td></tr>
<tr class="separator:gabff2d48de205687bc6ede2aeba7848b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga865a1f624059f698d927661661224d72"><td class="memItemLeft" align="right" valign="top"><a id="ga865a1f624059f698d927661661224d72" name="ga865a1f624059f698d927661661224d72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, char *value)</td></tr>
<tr class="separator:ga865a1f624059f698d927661661224d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79607161274a4ca236ee5222ba09a21f"><td class="memItemLeft" align="right" valign="top"><a id="ga79607161274a4ca236ee5222ba09a21f" name="ga79607161274a4ca236ee5222ba09a21f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *value)</td></tr>
<tr class="separator:ga79607161274a4ca236ee5222ba09a21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00edfe5c0889b70024d59dce01c0f754"><td class="memItemLeft" align="right" valign="top"><a id="ga00edfe5c0889b70024d59dce01c0f754" name="ga00edfe5c0889b70024d59dce01c0f754"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write_kv</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *key, int8_t value)</td></tr>
<tr class="separator:ga00edfe5c0889b70024d59dce01c0f754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d205f3ffe197ff8e8cc65a38eb9df00"><td class="memItemLeft" align="right" valign="top"><a id="ga8d205f3ffe197ff8e8cc65a38eb9df00" name="ga8d205f3ffe197ff8e8cc65a38eb9df00"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write_kv</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *key, int16_t value)</td></tr>
<tr class="separator:ga8d205f3ffe197ff8e8cc65a38eb9df00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96863ddeaf9b7afb3f56f2cef4d802ae"><td class="memItemLeft" align="right" valign="top"><a id="ga96863ddeaf9b7afb3f56f2cef4d802ae" name="ga96863ddeaf9b7afb3f56f2cef4d802ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write_kv</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *key, int32_t value)</td></tr>
<tr class="separator:ga96863ddeaf9b7afb3f56f2cef4d802ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03128d59246c0773c8e9cb46d8e5a142"><td class="memItemLeft" align="right" valign="top"><a id="ga03128d59246c0773c8e9cb46d8e5a142" name="ga03128d59246c0773c8e9cb46d8e5a142"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write_kv</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *key, int64_t value)</td></tr>
<tr class="separator:ga03128d59246c0773c8e9cb46d8e5a142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a8b5db4a84cacb1afea78f087c39879"><td class="memItemLeft" align="right" valign="top"><a id="ga0a8b5db4a84cacb1afea78f087c39879" name="ga0a8b5db4a84cacb1afea78f087c39879"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write_kv</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *key, uint8_t value)</td></tr>
<tr class="separator:ga0a8b5db4a84cacb1afea78f087c39879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfadeee8fff1a482427c7016139ccbc9"><td class="memItemLeft" align="right" valign="top"><a id="gacfadeee8fff1a482427c7016139ccbc9" name="gacfadeee8fff1a482427c7016139ccbc9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write_kv</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *key, uint16_t value)</td></tr>
<tr class="separator:gacfadeee8fff1a482427c7016139ccbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad514244127e3abd45e51dd3ff2569e6c"><td class="memItemLeft" align="right" valign="top"><a id="gad514244127e3abd45e51dd3ff2569e6c" name="gad514244127e3abd45e51dd3ff2569e6c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write_kv</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *key, uint32_t value)</td></tr>
<tr class="separator:gad514244127e3abd45e51dd3ff2569e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8786631e5215f693f56838fb55114273"><td class="memItemLeft" align="right" valign="top"><a id="ga8786631e5215f693f56838fb55114273" name="ga8786631e5215f693f56838fb55114273"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write_kv</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *key, uint64_t value)</td></tr>
<tr class="separator:ga8786631e5215f693f56838fb55114273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae40c79c43696a00d3ada035687b739eb"><td class="memItemLeft" align="right" valign="top"><a id="gae40c79c43696a00d3ada035687b739eb" name="gae40c79c43696a00d3ada035687b739eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write_kv</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *key, bool value)</td></tr>
<tr class="separator:gae40c79c43696a00d3ada035687b739eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab26ecd51233d35d044edfed85b295f41"><td class="memItemLeft" align="right" valign="top"><a id="gab26ecd51233d35d044edfed85b295f41" name="gab26ecd51233d35d044edfed85b295f41"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write_kv</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *key, float value)</td></tr>
<tr class="separator:gab26ecd51233d35d044edfed85b295f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac208ffe193ee18de3929ad368566d417"><td class="memItemLeft" align="right" valign="top"><a id="gac208ffe193ee18de3929ad368566d417" name="gac208ffe193ee18de3929ad368566d417"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write_kv</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *key, double value)</td></tr>
<tr class="separator:gac208ffe193ee18de3929ad368566d417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2df774a5d7e5cb41bd3910881149c6c7"><td class="memItemLeft" align="right" valign="top"><a id="ga2df774a5d7e5cb41bd3910881149c6c7" name="ga2df774a5d7e5cb41bd3910881149c6c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write_kv</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *key, char *value)</td></tr>
<tr class="separator:ga2df774a5d7e5cb41bd3910881149c6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga937a0b4155a8d5140cf3095cfd21f256"><td class="memItemLeft" align="right" valign="top"><a id="ga937a0b4155a8d5140cf3095cfd21f256" name="ga937a0b4155a8d5140cf3095cfd21f256"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_write_kv</b> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *key, const char *value)</td></tr>
<tr class="separator:ga937a0b4155a8d5140cf3095cfd21f256"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Type-Generic Writers</h2></td></tr>
<tr class="memitem:gac2732bbff44cdba031ca8cda91e52c2f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gac2732bbff44cdba031ca8cda91e52c2f">mpack_write</a>(writer,  value)</td></tr>
<tr class="memdesc:gac2732bbff44cdba031ca8cda91e52c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-generic writer for primitive types.  <a href="group__writer.html#gac2732bbff44cdba031ca8cda91e52c2f">More...</a><br /></td></tr>
<tr class="separator:gac2732bbff44cdba031ca8cda91e52c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefac7e4f99a20a91752e36a71e673199"><td class="memItemLeft" align="right" valign="top"><a id="gaefac7e4f99a20a91752e36a71e673199" name="gaefac7e4f99a20a91752e36a71e673199"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MPACK_WRITE_GENERIC_FLOAT</b>&#160;&#160;&#160;float: <a class="el" href="group__writer.html#ga285ce9cc180f3b623fbf07c67e2f9ca3">mpack_write_float</a>,</td></tr>
<tr class="separator:gaefac7e4f99a20a91752e36a71e673199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dc8208a79a35c7d0bd6f4e7a4bb704a"><td class="memItemLeft" align="right" valign="top"><a id="ga8dc8208a79a35c7d0bd6f4e7a4bb704a" name="ga8dc8208a79a35c7d0bd6f4e7a4bb704a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MPACK_WRITE_GENERIC_DOUBLE</b>&#160;&#160;&#160;double: <a class="el" href="group__writer.html#ga2bc0c6c6416b9d808be718b41681fd25">mpack_write_double</a>,</td></tr>
<tr class="separator:ga8dc8208a79a35c7d0bd6f4e7a4bb704a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad54b1e0dd9f6e218f5b6d66f787fd7cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gad54b1e0dd9f6e218f5b6d66f787fd7cc">mpack_write_kv</a>(writer,  key,  value)</td></tr>
<tr class="memdesc:gad54b1e0dd9f6e218f5b6d66f787fd7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-generic writer for key-value pairs of null-terminated string keys and primitive values.  <a href="group__writer.html#gad54b1e0dd9f6e218f5b6d66f787fd7cc">More...</a><br /></td></tr>
<tr class="separator:gad54b1e0dd9f6e218f5b6d66f787fd7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gac2732bbff44cdba031ca8cda91e52c2f" name="gac2732bbff44cdba031ca8cda91e52c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2732bbff44cdba031ca8cda91e52c2f">&#9670;&#160;</a></span>mpack_write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mpack_write</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">writer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    _Generic(((<span class="keywordtype">void</span>)0, value),                      \</div>
<div class="line">              int8_t: <a class="code hl_function" href="group__writer.html#ga4776a1693cf3d69f628ea0306b3867ac">mpack_write_i8</a>,               \</div>
<div class="line">             int16_t: <a class="code hl_function" href="group__writer.html#gabf30d21cb4c7c77c4ef99f9f9a1a8791">mpack_write_i16</a>,              \</div>
<div class="line">             int32_t: <a class="code hl_function" href="group__writer.html#ga3a437633c12478dc827977dc7cf6eb66">mpack_write_i32</a>,              \</div>
<div class="line">             int64_t: <a class="code hl_function" href="group__writer.html#gab8fcdb4f4ff97c3197a8bb809b88a167">mpack_write_i64</a>,              \</div>
<div class="line">             uint8_t: <a class="code hl_function" href="group__writer.html#ga573a41209a4b9125ee28c19cddef309a">mpack_write_u8</a>,               \</div>
<div class="line">            uint16_t: <a class="code hl_function" href="group__writer.html#gabfd74ba7f9f7fddb04d5b4fc5775342d">mpack_write_u16</a>,              \</div>
<div class="line">            uint32_t: <a class="code hl_function" href="group__writer.html#ga6c20b876be3a17487a6de49cf5a29b57">mpack_write_u32</a>,              \</div>
<div class="line">            uint64_t: <a class="code hl_function" href="group__writer.html#ga41d333e6d813655b8054c5ec53832c7c">mpack_write_u64</a>,              \</div>
<div class="line">                <span class="keywordtype">bool</span>: <a class="code hl_function" href="group__writer.html#ga5d8fa89f571534f5ddbdf81f5bbd5de8">mpack_write_bool</a>,             \</div>
<div class="line">            MPACK_WRITE_GENERIC_FLOAT               \</div>
<div class="line">            MPACK_WRITE_GENERIC_DOUBLE              \</div>
<div class="line">              <span class="keywordtype">char</span> *: <a class="code hl_function" href="group__writer.html#ga661a99e165400758fcd692a2c4dc5cb6">mpack_write_cstr_or_nil</a>,      \</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span> *: <a class="code hl_function" href="group__writer.html#ga661a99e165400758fcd692a2c4dc5cb6">mpack_write_cstr_or_nil</a>       \</div>
<div class="line">    )(writer, value)</div>
<div class="ttc" id="agroup__writer_html_ga3a437633c12478dc827977dc7cf6eb66"><div class="ttname"><a href="group__writer.html#ga3a437633c12478dc827977dc7cf6eb66">mpack_write_i32</a></div><div class="ttdeci">void mpack_write_i32(mpack_writer_t *writer, int32_t value)</div><div class="ttdoc">Writes a 32-bit integer in the most efficient packing available.</div></div>
<div class="ttc" id="agroup__writer_html_ga41d333e6d813655b8054c5ec53832c7c"><div class="ttname"><a href="group__writer.html#ga41d333e6d813655b8054c5ec53832c7c">mpack_write_u64</a></div><div class="ttdeci">void mpack_write_u64(mpack_writer_t *writer, uint64_t value)</div><div class="ttdoc">Writes an 64-bit unsigned integer in the most efficient packing available.</div></div>
<div class="ttc" id="agroup__writer_html_ga4776a1693cf3d69f628ea0306b3867ac"><div class="ttname"><a href="group__writer.html#ga4776a1693cf3d69f628ea0306b3867ac">mpack_write_i8</a></div><div class="ttdeci">void mpack_write_i8(mpack_writer_t *writer, int8_t value)</div><div class="ttdoc">Writes an 8-bit integer in the most efficient packing available.</div></div>
<div class="ttc" id="agroup__writer_html_ga573a41209a4b9125ee28c19cddef309a"><div class="ttname"><a href="group__writer.html#ga573a41209a4b9125ee28c19cddef309a">mpack_write_u8</a></div><div class="ttdeci">void mpack_write_u8(mpack_writer_t *writer, uint8_t value)</div><div class="ttdoc">Writes an 8-bit unsigned integer in the most efficient packing available.</div></div>
<div class="ttc" id="agroup__writer_html_ga5d8fa89f571534f5ddbdf81f5bbd5de8"><div class="ttname"><a href="group__writer.html#ga5d8fa89f571534f5ddbdf81f5bbd5de8">mpack_write_bool</a></div><div class="ttdeci">void mpack_write_bool(mpack_writer_t *writer, bool value)</div><div class="ttdoc">Writes a boolean.</div></div>
<div class="ttc" id="agroup__writer_html_ga661a99e165400758fcd692a2c4dc5cb6"><div class="ttname"><a href="group__writer.html#ga661a99e165400758fcd692a2c4dc5cb6">mpack_write_cstr_or_nil</a></div><div class="ttdeci">void mpack_write_cstr_or_nil(mpack_writer_t *writer, const char *cstr)</div><div class="ttdoc">Writes a null-terminated string, or a nil node if the given cstr pointer is NULL.</div></div>
<div class="ttc" id="agroup__writer_html_ga6c20b876be3a17487a6de49cf5a29b57"><div class="ttname"><a href="group__writer.html#ga6c20b876be3a17487a6de49cf5a29b57">mpack_write_u32</a></div><div class="ttdeci">void mpack_write_u32(mpack_writer_t *writer, uint32_t value)</div><div class="ttdoc">Writes an 32-bit unsigned integer in the most efficient packing available.</div></div>
<div class="ttc" id="agroup__writer_html_gab8fcdb4f4ff97c3197a8bb809b88a167"><div class="ttname"><a href="group__writer.html#gab8fcdb4f4ff97c3197a8bb809b88a167">mpack_write_i64</a></div><div class="ttdeci">void mpack_write_i64(mpack_writer_t *writer, int64_t value)</div><div class="ttdoc">Writes a 64-bit integer in the most efficient packing available.</div></div>
<div class="ttc" id="agroup__writer_html_gabf30d21cb4c7c77c4ef99f9f9a1a8791"><div class="ttname"><a href="group__writer.html#gabf30d21cb4c7c77c4ef99f9f9a1a8791">mpack_write_i16</a></div><div class="ttdeci">void mpack_write_i16(mpack_writer_t *writer, int16_t value)</div><div class="ttdoc">Writes a 16-bit integer in the most efficient packing available.</div></div>
<div class="ttc" id="agroup__writer_html_gabfd74ba7f9f7fddb04d5b4fc5775342d"><div class="ttname"><a href="group__writer.html#gabfd74ba7f9f7fddb04d5b4fc5775342d">mpack_write_u16</a></div><div class="ttdeci">void mpack_write_u16(mpack_writer_t *writer, uint16_t value)</div><div class="ttdoc">Writes an 16-bit unsigned integer in the most efficient packing available.</div></div>
</div><!-- fragment -->
<p>Type-generic writer for primitive types. </p>
<p >The compiler will dispatch to an appropriate write function based on the type of the <em>value</em> parameter.</p>
<dl class="section note"><dt>Note</dt><dd>This requires C11 <code>_Generic</code> support. (A set of inline overloads are used in C++ to provide the same functionality.)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In C11, the indentifiers <code>true</code>, <code>false</code> and <code>NULL</code> are all of type <code>int</code>, not <code>bool</code> or <code>void*</code>! They will emit unexpected types when passed uncast, so be careful when using them. </dd></dl>

</div>
</div>
<a id="gad54b1e0dd9f6e218f5b6d66f787fd7cc" name="gad54b1e0dd9f6e218f5b6d66f787fd7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad54b1e0dd9f6e218f5b6d66f787fd7cc">&#9670;&#160;</a></span>mpack_write_kv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mpack_write_kv</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">writer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {     \</div>
<div class="line">    mpack_write_cstr(writer, key);                  \</div>
<div class="line">    mpack_write(writer, value);                     \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
<p>Type-generic writer for key-value pairs of null-terminated string keys and primitive values. </p>
<dl class="section warning"><dt>Warning</dt><dd><em>writer</em> may be evaluated multiple times.</dd>
<dd>
In C11, the indentifiers <code>true</code>, <code>false</code> and <code>NULL</code> are all of type <code>int</code>, not <code>bool</code> or <code>void*</code>! They will emit unexpected types when passed uncast, so be careful when using them.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writer</td><td>The writer. </td></tr>
    <tr><td class="paramname">key</td><td>A null-terminated C string. </td></tr>
    <tr><td class="paramname">value</td><td>A primitive type supported by <a class="el" href="group__writer.html#gac2732bbff44cdba031ca8cda91e52c2f" title="Type-generic writer for primitive types.">mpack_write()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga34786576628c2f814b5d109daf0af7d1" name="ga34786576628c2f814b5d109daf0af7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34786576628c2f814b5d109daf0af7d1">&#9670;&#160;</a></span>MPACK_WRITER_MINIMUM_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MPACK_WRITER_MINIMUM_BUFFER_SIZE&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The minimum buffer size for a writer with a flush function. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga65d410be0305a59ec15cfe700f8b036a" name="ga65d410be0305a59ec15cfe700f8b036a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65d410be0305a59ec15cfe700f8b036a">&#9670;&#160;</a></span>mpack_writer_error_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mpack_writer_error_t) (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An error handler function to be called when an error is flagged on the writer. </p>
<p >The error handler will only be called once on the first error flagged; any subsequent writes and errors are ignored, and the writer is permanently in that error state.</p>
<p >MPack is safe against non-local jumps out of error handler callbacks. This means you are allowed to longjmp or throw an exception (in C++, Objective-C, or with SEH) out of this callback.</p>
<p >Bear in mind when using longjmp that local non-volatile variables that have changed are undefined when setjmp() returns, so you can't put the writer on the stack in the same activation frame as the setjmp without declaring it volatile.</p>
<p >You must still eventually destroy the writer. It is not destroyed automatically when an error is flagged. It is safe to destroy the writer within this error callback, but you will either need to perform a non-local jump, or store something in your context to identify that the writer is destroyed since any future accesses to it cause undefined behavior. </p>

</div>
</div>
<a id="gad5749babfacaa707cbaff06bcbc790a5" name="gad5749babfacaa707cbaff06bcbc790a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5749babfacaa707cbaff06bcbc790a5">&#9670;&#160;</a></span>mpack_writer_flush_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mpack_writer_flush_t) (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *buffer, size_t count)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The MPack writer's flush function to flush the buffer to the output stream. </p>
<p >It should flag an appropriate error on the writer if flushing fails (usually mpack_error_io or mpack_error_memory.)</p>
<p >The specified context for callbacks is at writer-&gt;context. </p>

</div>
</div>
<a id="gabdb207d4ba6a6ae47efa5ede13436f31" name="gabdb207d4ba6a6ae47efa5ede13436f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdb207d4ba6a6ae47efa5ede13436f31">&#9670;&#160;</a></span>mpack_writer_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> <a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A buffered MessagePack encoder. </p>
<p >The encoder wraps an existing buffer and, optionally, a flush function. This allows efficiently encoding to an in-memory buffer or to a stream.</p>
<p >All write operations are synchronous; they will block until the data is fully written, or an error occurs. </p>

</div>
</div>
<a id="ga97ccab59b332d882d386c10b241eb888" name="ga97ccab59b332d882d386c10b241eb888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97ccab59b332d882d386c10b241eb888">&#9670;&#160;</a></span>mpack_writer_teardown_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mpack_writer_teardown_t) (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A teardown function to be called when the writer is destroyed. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5e10cc90afff17e2c4352c4399be9433" name="ga5e10cc90afff17e2c4352c4399be9433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e10cc90afff17e2c4352c4399be9433">&#9670;&#160;</a></span>mpack_build_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_build_array </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts building an array. </p>
<p >Elements must follow, and <a class="el" href="group__writer.html#ga65e149d035d8de105774ebad2363cac5" title="Completes an array being built.">mpack_complete_array()</a> must be called when done. The number of elements is determined automatically.</p>
<p >If you know ahead of time the number of elements in the array, it is more efficient to call <a class="el" href="group__writer.html#ga3d2c452b01415f7d86db2ecd1a5aa329" title="Opens an array.">mpack_start_array()</a> instead, even if you are already within another open build.</p>
<p >Builder containers can be nested within normal (known size) containers and vice versa. You can call <a class="el" href="group__writer.html#ga5e10cc90afff17e2c4352c4399be9433" title="Starts building an array.">mpack_build_array()</a>, then <a class="el" href="group__writer.html#ga3d2c452b01415f7d86db2ecd1a5aa329" title="Opens an array.">mpack_start_array()</a> inside it, then <a class="el" href="group__writer.html#ga5e10cc90afff17e2c4352c4399be9433" title="Starts building an array.">mpack_build_array()</a> inside that, and so forth.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#ga65e149d035d8de105774ebad2363cac5" title="Completes an array being built.">mpack_complete_array()</a> to complete this array </dd>
<dd>
<a class="el" href="group__writer.html#ga3d2c452b01415f7d86db2ecd1a5aa329" title="Opens an array.">mpack_start_array()</a> if you already know the size of the array </dd>
<dd>
<a class="el" href="group__writer.html#ga5849bab4afebddae63bb03f5dce5f7d8" title="Starts building a map.">mpack_build_map()</a> for implementation details </dd></dl>

</div>
</div>
<a id="ga5849bab4afebddae63bb03f5dce5f7d8" name="ga5849bab4afebddae63bb03f5dce5f7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5849bab4afebddae63bb03f5dce5f7d8">&#9670;&#160;</a></span>mpack_build_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_build_map </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts building a map. </p>
<p >An even number of elements must follow, and <a class="el" href="group__writer.html#ga10d9f55e0a512d88ede66bbbc543f711" title="Completes a map being built.">mpack_complete_map()</a> must be called when done. The number of elements is determined automatically.</p>
<p >If you know ahead of time the number of elements in the map, it is more efficient to call <a class="el" href="group__writer.html#ga5c54c857ce7f0bdcea9b2df349cbcc61" title="Opens a map.">mpack_start_map()</a> instead, even if you are already within another open build.</p>
<p >Builder containers can be nested within normal (known size) containers and vice versa. You can call <a class="el" href="group__writer.html#ga5849bab4afebddae63bb03f5dce5f7d8" title="Starts building a map.">mpack_build_map()</a>, then <a class="el" href="group__writer.html#ga5c54c857ce7f0bdcea9b2df349cbcc61" title="Opens a map.">mpack_start_map()</a> inside it, then <a class="el" href="group__writer.html#ga5849bab4afebddae63bb03f5dce5f7d8" title="Starts building a map.">mpack_build_map()</a> inside that, and so forth.</p>
<p >A writer in build mode diverts writes to a builder buffer that allocates as needed. Once the last map or array being built is completed, the deferred message is composed with computed array and map sizes into the writer. Builder maps and arrays are encoded exactly the same as ordinary maps and arrays in the final message.</p>
<p >This indirect encoding is costly, as it incurs at least an extra copy of all data written within a builder (but not additional copies for nested builders.) Expect a speed penalty of half or more.</p>
<p >A good strategy is to use this during early development when your messages are constantly changing, and then closer to release when your message formats have stabilized, replace all your build calls with start calls with pre-computed sizes. Or don't, if you find the builder has little impact on performance, because even with builders MPack is extremely fast.</p>
<dl class="section note"><dt>Note</dt><dd>When an array or map starts being built, nothing will be flushed until it is completed. If you are building a large message that does not fit in the output stream, you won't get an error about it until everything is written.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#ga10d9f55e0a512d88ede66bbbc543f711" title="Completes a map being built.">mpack_complete_map()</a> to complete this map </dd>
<dd>
<a class="el" href="group__writer.html#ga5c54c857ce7f0bdcea9b2df349cbcc61" title="Opens a map.">mpack_start_map()</a> if you already know the size of the map </dd></dl>

</div>
</div>
<a id="ga65e149d035d8de105774ebad2363cac5" name="ga65e149d035d8de105774ebad2363cac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65e149d035d8de105774ebad2363cac5">&#9670;&#160;</a></span>mpack_complete_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_complete_array </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Completes an array being built. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#ga5e10cc90afff17e2c4352c4399be9433" title="Starts building an array.">mpack_build_array()</a> </dd></dl>

</div>
</div>
<a id="ga10d9f55e0a512d88ede66bbbc543f711" name="ga10d9f55e0a512d88ede66bbbc543f711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10d9f55e0a512d88ede66bbbc543f711">&#9670;&#160;</a></span>mpack_complete_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_complete_map </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Completes a map being built. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#ga5849bab4afebddae63bb03f5dce5f7d8" title="Starts building a map.">mpack_build_map()</a> </dd></dl>

</div>
</div>
<a id="gaa7ae76ab1bf912e1db537cad69cf5f31" name="gaa7ae76ab1bf912e1db537cad69cf5f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7ae76ab1bf912e1db537cad69cf5f31">&#9670;&#160;</a></span>mpack_finish_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_finish_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes writing an array. </p>
<p >This should be called only after a corresponding call to <a class="el" href="group__writer.html#ga3d2c452b01415f7d86db2ecd1a5aa329" title="Opens an array.">mpack_start_array()</a> and after the array contents are written.</p>
<p >In debug mode (or if MPACK_WRITE_TRACKING is not 0), this will track writes to ensure that the correct number of elements are written.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#ga3d2c452b01415f7d86db2ecd1a5aa329" title="Opens an array.">mpack_start_array()</a> </dd></dl>

</div>
</div>
<a id="gaaff7b65b611db3cf5b165b7efed0f0f2" name="gaaff7b65b611db3cf5b165b7efed0f0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaff7b65b611db3cf5b165b7efed0f0f2">&#9670;&#160;</a></span>mpack_finish_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_finish_bin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes writing a binary blob. </p>
<p >This should be called only after a corresponding call to <a class="el" href="group__writer.html#ga9d9d905358fe553360e3071485f75b4d" title="Opens a binary blob.">mpack_start_bin()</a> and after the binary bytes are written with <a class="el" href="group__writer.html#ga7f594d59ddfd2729aa2b3758e1641139" title="Writes a portion of bytes for a string, binary blob or extension type which was opened by mpack_write...">mpack_write_bytes()</a>.</p>
<p >This will track writes to ensure that the correct number of bytes are written.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#ga9d9d905358fe553360e3071485f75b4d" title="Opens a binary blob.">mpack_start_bin()</a> </dd>
<dd>
<a class="el" href="group__writer.html#ga7f594d59ddfd2729aa2b3758e1641139" title="Writes a portion of bytes for a string, binary blob or extension type which was opened by mpack_write...">mpack_write_bytes()</a> </dd></dl>

</div>
</div>
<a id="ga7f93f96c951f17bba8cd26a6f50db8e2" name="ga7f93f96c951f17bba8cd26a6f50db8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f93f96c951f17bba8cd26a6f50db8e2">&#9670;&#160;</a></span>mpack_finish_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_finish_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes writing an extended type binary data blob. </p>
<p >This should be called only after a corresponding call to <a class="el" href="group__writer.html#ga9d9d905358fe553360e3071485f75b4d" title="Opens a binary blob.">mpack_start_bin()</a> and after the binary bytes are written with <a class="el" href="group__writer.html#ga7f594d59ddfd2729aa2b3758e1641139" title="Writes a portion of bytes for a string, binary blob or extension type which was opened by mpack_write...">mpack_write_bytes()</a>.</p>
<p >This will track writes to ensure that the correct number of bytes are written.</p>
<dl class="section note"><dt>Note</dt><dd>This requires <a class="el" href="group__config.html#gab1d8587f6e314e491c7fdb262f0b2bd1">MPACK_EXTENSIONS</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#gab9cd08887689641c3d71cea6f536b6f8" title="Opens an extension type.">mpack_start_ext()</a> </dd>
<dd>
<a class="el" href="group__writer.html#ga7f594d59ddfd2729aa2b3758e1641139" title="Writes a portion of bytes for a string, binary blob or extension type which was opened by mpack_write...">mpack_write_bytes()</a> </dd></dl>

</div>
</div>
<a id="gabf0ab209845e7c9c3df7aa00b0d59a03" name="gabf0ab209845e7c9c3df7aa00b0d59a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf0ab209845e7c9c3df7aa00b0d59a03">&#9670;&#160;</a></span>mpack_finish_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_finish_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes writing a map. </p>
<p >This should be called only after a corresponding call to <a class="el" href="group__writer.html#ga5c54c857ce7f0bdcea9b2df349cbcc61" title="Opens a map.">mpack_start_map()</a> and after the map contents are written.</p>
<p >In debug mode (or if MPACK_WRITE_TRACKING is not 0), this will track writes to ensure that the correct number of elements are written.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#ga5c54c857ce7f0bdcea9b2df349cbcc61" title="Opens a map.">mpack_start_map()</a> </dd></dl>

</div>
</div>
<a id="ga44f9dd4d379b70fb9534cf1e359e3d4a" name="ga44f9dd4d379b70fb9534cf1e359e3d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44f9dd4d379b70fb9534cf1e359e3d4a">&#9670;&#160;</a></span>mpack_finish_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_finish_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes writing a string. </p>
<p >This should be called only after a corresponding call to <a class="el" href="group__writer.html#ga0f293abb4441a1113b2ed956c3e735ad" title="Opens a string.">mpack_start_str()</a> and after the string bytes are written with <a class="el" href="group__writer.html#ga7f594d59ddfd2729aa2b3758e1641139" title="Writes a portion of bytes for a string, binary blob or extension type which was opened by mpack_write...">mpack_write_bytes()</a>.</p>
<p >This will track writes to ensure that the correct number of elements are written.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#ga0f293abb4441a1113b2ed956c3e735ad" title="Opens a string.">mpack_start_str()</a> </dd>
<dd>
<a class="el" href="group__writer.html#ga7f594d59ddfd2729aa2b3758e1641139" title="Writes a portion of bytes for a string, binary blob or extension type which was opened by mpack_write...">mpack_write_bytes()</a> </dd></dl>

</div>
</div>
<a id="gaecfb47a0e86d293ca002f1e11b2edb38" name="gaecfb47a0e86d293ca002f1e11b2edb38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecfb47a0e86d293ca002f1e11b2edb38">&#9670;&#160;</a></span>mpack_finish_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_finish_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga22f03cf1240d5a917e1b3e7be8ab327e">mpack_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes writing the given compound type. </p>
<p >This will track writes to ensure that the correct number of elements or bytes are written.</p>
<p >This can be called with the appropriate type instead the corresponding mpack_finish_*() function if you want to finish a dynamic type. </p>

</div>
</div>
<a id="ga3d2c452b01415f7d86db2ecd1a5aa329" name="ga3d2c452b01415f7d86db2ecd1a5aa329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d2c452b01415f7d86db2ecd1a5aa329">&#9670;&#160;</a></span>mpack_start_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_start_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens an array. </p>
<p ><code>count</code> elements must follow, and <a class="el" href="group__writer.html#gaa7ae76ab1bf912e1db537cad69cf5f31" title="Finishes writing an array.">mpack_finish_array()</a> must be called when done.</p>
<p >If you do not know the number of elements to be written ahead of time, call <a class="el" href="group__writer.html#ga5e10cc90afff17e2c4352c4399be9433" title="Starts building an array.">mpack_build_array()</a> instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#gaa7ae76ab1bf912e1db537cad69cf5f31" title="Finishes writing an array.">mpack_finish_array()</a> </dd>
<dd>
<a class="el" href="group__writer.html#ga5e10cc90afff17e2c4352c4399be9433" title="Starts building an array.">mpack_build_array()</a> to count the number of elements automatically </dd></dl>

</div>
</div>
<a id="ga9d9d905358fe553360e3071485f75b4d" name="ga9d9d905358fe553360e3071485f75b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d9d905358fe553360e3071485f75b4d">&#9670;&#160;</a></span>mpack_start_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_start_bin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a binary blob. </p>
<p ><code>count</code> bytes should be written with calls to <a class="el" href="group__writer.html#ga7f594d59ddfd2729aa2b3758e1641139" title="Writes a portion of bytes for a string, binary blob or extension type which was opened by mpack_write...">mpack_write_bytes()</a>, and <a class="el" href="group__writer.html#gaaff7b65b611db3cf5b165b7efed0f0f2" title="Finishes writing a binary blob.">mpack_finish_bin()</a> should be called when done. </p>

</div>
</div>
<a id="gab9cd08887689641c3d71cea6f536b6f8" name="gab9cd08887689641c3d71cea6f536b6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9cd08887689641c3d71cea6f536b6f8">&#9670;&#160;</a></span>mpack_start_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_start_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>exttype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens an extension type. </p>
<p ><code>count</code> bytes should be written with calls to <a class="el" href="group__writer.html#ga7f594d59ddfd2729aa2b3758e1641139" title="Writes a portion of bytes for a string, binary blob or extension type which was opened by mpack_write...">mpack_write_bytes()</a>, and <a class="el" href="group__writer.html#ga7f93f96c951f17bba8cd26a6f50db8e2" title="Finishes writing an extended type binary data blob.">mpack_finish_ext()</a> should be called when done.</p>
<p >Extension types [0, 127] are available for application-specific types. Extension types [-128, -1] are reserved for future extensions of MessagePack.</p>
<dl class="section note"><dt>Note</dt><dd>This requires <a class="el" href="group__config.html#gab1d8587f6e314e491c7fdb262f0b2bd1">MPACK_EXTENSIONS</a>. </dd></dl>

</div>
</div>
<a id="ga5c54c857ce7f0bdcea9b2df349cbcc61" name="ga5c54c857ce7f0bdcea9b2df349cbcc61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c54c857ce7f0bdcea9b2df349cbcc61">&#9670;&#160;</a></span>mpack_start_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_start_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a map. </p>
<p ><code>count * 2</code> elements must follow, and <a class="el" href="group__writer.html#gabf0ab209845e7c9c3df7aa00b0d59a03" title="Finishes writing a map.">mpack_finish_map()</a> must be called when done.</p>
<p >If you do not know the number of elements to be written ahead of time, call <a class="el" href="group__writer.html#ga5849bab4afebddae63bb03f5dce5f7d8" title="Starts building a map.">mpack_build_map()</a> instead.</p>
<p >Remember that while map elements in MessagePack are implicitly ordered, they are not ordered in JSON. If you need elements to be read back in the order they are written, consider use an array instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#gabf0ab209845e7c9c3df7aa00b0d59a03" title="Finishes writing a map.">mpack_finish_map()</a> </dd>
<dd>
<a class="el" href="group__writer.html#ga5849bab4afebddae63bb03f5dce5f7d8" title="Starts building a map.">mpack_build_map()</a> to count the number of key/value pairs automatically </dd></dl>

</div>
</div>
<a id="ga0f293abb4441a1113b2ed956c3e735ad" name="ga0f293abb4441a1113b2ed956c3e735ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f293abb4441a1113b2ed956c3e735ad">&#9670;&#160;</a></span>mpack_start_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_start_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a string. </p>
<p ><code>count</code> bytes should be written with calls to <a class="el" href="group__writer.html#ga7f594d59ddfd2729aa2b3758e1641139" title="Writes a portion of bytes for a string, binary blob or extension type which was opened by mpack_write...">mpack_write_bytes()</a>, and <a class="el" href="group__writer.html#ga44f9dd4d379b70fb9534cf1e359e3d4a" title="Finishes writing a string.">mpack_finish_str()</a> should be called when done.</p>
<p >To write an entire string at once, use <a class="el" href="group__writer.html#gabdd346fe4eb4e1737807932d19a2909f" title="Writes a string.">mpack_write_str()</a> or <a class="el" href="group__writer.html#ga3bd01df04f36b5feb770f449b83995b6" title="Writes a null-terminated string.">mpack_write_cstr()</a> instead.</p>
<p >MPack does not care about the underlying encoding, but UTF-8 is highly recommended, especially for compatibility with JSON. </p>

</div>
</div>
<a id="ga379b2db0595d0d0493946290dd827262" name="ga379b2db0595d0d0493946290dd827262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga379b2db0595d0d0493946290dd827262">&#9670;&#160;</a></span>mpack_write_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_bin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a binary blob. </p>
<p >To stream a binary blob in chunks, use <a class="el" href="group__writer.html#ga9d9d905358fe553360e3071485f75b4d" title="Opens a binary blob.">mpack_start_bin()</a> instead.</p>
<p >You should not call <a class="el" href="group__writer.html#gaaff7b65b611db3cf5b165b7efed0f0f2" title="Finishes writing a binary blob.">mpack_finish_bin()</a> after calling this; this performs both start and finish. </p>

</div>
</div>
<a id="ga5d8fa89f571534f5ddbdf81f5bbd5de8" name="ga5d8fa89f571534f5ddbdf81f5bbd5de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d8fa89f571534f5ddbdf81f5bbd5de8">&#9670;&#160;</a></span>mpack_write_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a boolean. </p>

</div>
</div>
<a id="ga7f594d59ddfd2729aa2b3758e1641139" name="ga7f594d59ddfd2729aa2b3758e1641139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f594d59ddfd2729aa2b3758e1641139">&#9670;&#160;</a></span>mpack_write_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a portion of bytes for a string, binary blob or extension type which was opened by <a class="el" href="group__writer.html#ga17155afc35912817c13802d502f14e80" title="Writes a MessagePack object header (an MPack Tag.)">mpack_write_tag()</a> or one of the mpack_start_*() functions. </p>
<p >This can be called multiple times to write the data in chunks, as long as the total amount of bytes written matches the count given when the compound type was started.</p>
<p >The corresponding mpack_finish_*() function must be called when done.</p>
<p >To write an entire string, binary blob or extension type at once, use one of the mpack_write_*() functions instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#ga17155afc35912817c13802d502f14e80" title="Writes a MessagePack object header (an MPack Tag.)">mpack_write_tag()</a> </dd>
<dd>
<a class="el" href="group__writer.html#ga0f293abb4441a1113b2ed956c3e735ad" title="Opens a string.">mpack_start_str()</a> </dd>
<dd>
<a class="el" href="group__writer.html#ga9d9d905358fe553360e3071485f75b4d" title="Opens a binary blob.">mpack_start_bin()</a> </dd>
<dd>
<a class="el" href="group__writer.html#gab9cd08887689641c3d71cea6f536b6f8" title="Opens an extension type.">mpack_start_ext()</a> </dd>
<dd>
<a class="el" href="group__writer.html#ga44f9dd4d379b70fb9534cf1e359e3d4a" title="Finishes writing a string.">mpack_finish_str()</a> </dd>
<dd>
<a class="el" href="group__writer.html#gaaff7b65b611db3cf5b165b7efed0f0f2" title="Finishes writing a binary blob.">mpack_finish_bin()</a> </dd>
<dd>
<a class="el" href="group__writer.html#ga7f93f96c951f17bba8cd26a6f50db8e2" title="Finishes writing an extended type binary data blob.">mpack_finish_ext()</a> </dd>
<dd>
<a class="el" href="group__writer.html#gaecfb47a0e86d293ca002f1e11b2edb38" title="Finishes writing the given compound type.">mpack_finish_type()</a> </dd></dl>

</div>
</div>
<a id="ga3bd01df04f36b5feb770f449b83995b6" name="ga3bd01df04f36b5feb770f449b83995b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bd01df04f36b5feb770f449b83995b6">&#9670;&#160;</a></span>mpack_write_cstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a null-terminated string. </p>
<p >(The null-terminator is not written.)</p>
<p >MPack does not care about the underlying encoding, but UTF-8 is highly recommended, especially for compatibility with JSON. You should consider calling <a class="el" href="group__writer.html#ga5c82b06ba51952b2c8f6508e69f3bcc5" title="Writes a null-terminated string, ensuring that it is valid UTF-8.">mpack_write_utf8_cstr()</a> instead, especially if you will be reading it back as UTF-8.</p>
<p >You should not call <a class="el" href="group__writer.html#ga44f9dd4d379b70fb9534cf1e359e3d4a" title="Finishes writing a string.">mpack_finish_str()</a> after calling this; this performs both start and finish. </p>

</div>
</div>
<a id="ga661a99e165400758fcd692a2c4dc5cb6" name="ga661a99e165400758fcd692a2c4dc5cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga661a99e165400758fcd692a2c4dc5cb6">&#9670;&#160;</a></span>mpack_write_cstr_or_nil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_cstr_or_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a null-terminated string, or a nil node if the given cstr pointer is NULL. </p>
<p >(The null-terminator is not written.)</p>
<p >MPack does not care about the underlying encoding, but UTF-8 is highly recommended, especially for compatibility with JSON. You should consider calling <a class="el" href="group__writer.html#ga2ef20cf65309d8deb6a11f6811c6b639" title="Writes a null-terminated string ensuring that it is valid UTF-8, or writes nil if the given cstr poin...">mpack_write_utf8_cstr_or_nil()</a> instead, especially if you will be reading it back as UTF-8.</p>
<p >You should not call <a class="el" href="group__writer.html#ga44f9dd4d379b70fb9534cf1e359e3d4a" title="Finishes writing a string.">mpack_finish_str()</a> after calling this; this performs both start and finish. </p>

</div>
</div>
<a id="ga2bc0c6c6416b9d808be718b41681fd25" name="ga2bc0c6c6416b9d808be718b41681fd25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bc0c6c6416b9d808be718b41681fd25">&#9670;&#160;</a></span>mpack_write_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a double. </p>

</div>
</div>
<a id="ga409f4bb30eb73628490ebf6f445fabc4" name="ga409f4bb30eb73628490ebf6f445fabc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga409f4bb30eb73628490ebf6f445fabc4">&#9670;&#160;</a></span>mpack_write_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>exttype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an extension type. </p>
<p >To stream an extension blob in chunks, use <a class="el" href="group__writer.html#gab9cd08887689641c3d71cea6f536b6f8" title="Opens an extension type.">mpack_start_ext()</a> instead.</p>
<p >Extension types [0, 127] are available for application-specific types. Extension types [-128, -1] are reserved for future extensions of MessagePack.</p>
<p >You should not call <a class="el" href="group__writer.html#ga7f93f96c951f17bba8cd26a6f50db8e2" title="Finishes writing an extended type binary data blob.">mpack_finish_ext()</a> after calling this; this performs both start and finish.</p>
<dl class="section note"><dt>Note</dt><dd>This requires <a class="el" href="group__config.html#gab1d8587f6e314e491c7fdb262f0b2bd1">MPACK_EXTENSIONS</a>. </dd></dl>

</div>
</div>
<a id="gab05b274195191e6e98c4a8d0ec730f63" name="gab05b274195191e6e98c4a8d0ec730f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab05b274195191e6e98c4a8d0ec730f63">&#9670;&#160;</a></span>mpack_write_false()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_false </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a boolean with value false. </p>

</div>
</div>
<a id="ga285ce9cc180f3b623fbf07c67e2f9ca3" name="ga285ce9cc180f3b623fbf07c67e2f9ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga285ce9cc180f3b623fbf07c67e2f9ca3">&#9670;&#160;</a></span>mpack_write_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a float. </p>

</div>
</div>
<a id="gabf30d21cb4c7c77c4ef99f9f9a1a8791" name="gabf30d21cb4c7c77c4ef99f9f9a1a8791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf30d21cb4c7c77c4ef99f9f9a1a8791">&#9670;&#160;</a></span>mpack_write_i16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_i16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a 16-bit integer in the most efficient packing available. </p>

</div>
</div>
<a id="ga3a437633c12478dc827977dc7cf6eb66" name="ga3a437633c12478dc827977dc7cf6eb66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a437633c12478dc827977dc7cf6eb66">&#9670;&#160;</a></span>mpack_write_i32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_i32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a 32-bit integer in the most efficient packing available. </p>

</div>
</div>
<a id="gab8fcdb4f4ff97c3197a8bb809b88a167" name="gab8fcdb4f4ff97c3197a8bb809b88a167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8fcdb4f4ff97c3197a8bb809b88a167">&#9670;&#160;</a></span>mpack_write_i64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_i64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a 64-bit integer in the most efficient packing available. </p>

</div>
</div>
<a id="ga4776a1693cf3d69f628ea0306b3867ac" name="ga4776a1693cf3d69f628ea0306b3867ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4776a1693cf3d69f628ea0306b3867ac">&#9670;&#160;</a></span>mpack_write_i8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_i8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an 8-bit integer in the most efficient packing available. </p>

</div>
</div>
<a id="gadf4d702ebb08c040512f141ed46395c7" name="gadf4d702ebb08c040512f141ed46395c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf4d702ebb08c040512f141ed46395c7">&#9670;&#160;</a></span>mpack_write_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an integer in the most efficient packing available. </p>

</div>
</div>
<a id="gaea8d479af0d05cff5194502362ae82a5" name="gaea8d479af0d05cff5194502362ae82a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea8d479af0d05cff5194502362ae82a5">&#9670;&#160;</a></span>mpack_write_nil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a nil. </p>

</div>
</div>
<a id="ga7a100199b2dc33b41fd5f99c428048ac" name="ga7a100199b2dc33b41fd5f99c428048ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a100199b2dc33b41fd5f99c428048ac">&#9670;&#160;</a></span>mpack_write_object_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_object_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a pre-encoded messagepack object. </p>

</div>
</div>
<a id="gabdd346fe4eb4e1737807932d19a2909f" name="gabdd346fe4eb4e1737807932d19a2909f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdd346fe4eb4e1737807932d19a2909f">&#9670;&#160;</a></span>mpack_write_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a string. </p>
<p >To stream a string in chunks, use <a class="el" href="group__writer.html#ga0f293abb4441a1113b2ed956c3e735ad" title="Opens a string.">mpack_start_str()</a> instead.</p>
<p >MPack does not care about the underlying encoding, but UTF-8 is highly recommended, especially for compatibility with JSON. You should consider calling <a class="el" href="group__writer.html#ga5284de75985bd7a41997766fdab107f3" title="Writes a string, ensuring that it is valid UTF-8.">mpack_write_utf8()</a> instead, especially if you will be reading it back as UTF-8.</p>
<p >You should not call <a class="el" href="group__writer.html#ga44f9dd4d379b70fb9534cf1e359e3d4a" title="Finishes writing a string.">mpack_finish_str()</a> after calling this; this performs both start and finish. </p>

</div>
</div>
<a id="ga17155afc35912817c13802d502f14e80" name="ga17155afc35912817c13802d502f14e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17155afc35912817c13802d502f14e80">&#9670;&#160;</a></span>mpack_write_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga008da69ac6b5582a893f2d2ffd37f4ac">mpack_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a MessagePack object header (an MPack Tag.) </p>
<p >If the value is a map, array, string, binary or extension type, the containing elements or bytes must be written separately and the appropriate finish function must be called (as though one of the mpack_start_*() functions was called.)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#ga7f594d59ddfd2729aa2b3758e1641139" title="Writes a portion of bytes for a string, binary blob or extension type which was opened by mpack_write...">mpack_write_bytes()</a> </dd>
<dd>
<a class="el" href="group__writer.html#gabf0ab209845e7c9c3df7aa00b0d59a03" title="Finishes writing a map.">mpack_finish_map()</a> </dd>
<dd>
<a class="el" href="group__writer.html#gaa7ae76ab1bf912e1db537cad69cf5f31" title="Finishes writing an array.">mpack_finish_array()</a> </dd>
<dd>
<a class="el" href="group__writer.html#ga44f9dd4d379b70fb9534cf1e359e3d4a" title="Finishes writing a string.">mpack_finish_str()</a> </dd>
<dd>
<a class="el" href="group__writer.html#gaaff7b65b611db3cf5b165b7efed0f0f2" title="Finishes writing a binary blob.">mpack_finish_bin()</a> </dd>
<dd>
<a class="el" href="group__writer.html#ga7f93f96c951f17bba8cd26a6f50db8e2" title="Finishes writing an extended type binary data blob.">mpack_finish_ext()</a> </dd>
<dd>
<a class="el" href="group__writer.html#gaecfb47a0e86d293ca002f1e11b2edb38" title="Finishes writing the given compound type.">mpack_finish_type()</a> </dd></dl>

</div>
</div>
<a id="ga3f30a610b72615b21e69b7639781901d" name="ga3f30a610b72615b21e69b7639781901d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f30a610b72615b21e69b7639781901d">&#9670;&#160;</a></span>mpack_write_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_timestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>seconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nanoseconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a timestamp. </p>
<dl class="section note"><dt>Note</dt><dd>This requires <a class="el" href="group__config.html#gab1d8587f6e314e491c7fdb262f0b2bd1">MPACK_EXTENSIONS</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writer</td><td>The writer </td></tr>
    <tr><td class="paramname">seconds</td><td>The (signed) number of seconds since 1970-01-01T00:00:00Z. </td></tr>
    <tr><td class="paramname">nanoseconds</td><td>The additional number of nanoseconds from 0 to 999,999,999 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8fdbdacfa5c2518ed0ea31d44f676e4" name="gad8fdbdacfa5c2518ed0ea31d44f676e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8fdbdacfa5c2518ed0ea31d44f676e4">&#9670;&#160;</a></span>mpack_write_timestamp_seconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_timestamp_seconds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>seconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a timestamp with the given number of seconds (and zero nanoseconds). </p>
<dl class="section note"><dt>Note</dt><dd>This requires <a class="el" href="group__config.html#gab1d8587f6e314e491c7fdb262f0b2bd1">MPACK_EXTENSIONS</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writer</td><td>The writer </td></tr>
    <tr><td class="paramname">seconds</td><td>The (signed) number of seconds since 1970-01-01T00:00:00Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga635ed35d21688d038f5fabfcfeab32a5" name="ga635ed35d21688d038f5fabfcfeab32a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga635ed35d21688d038f5fabfcfeab32a5">&#9670;&#160;</a></span>mpack_write_timestamp_struct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_timestamp_struct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#structmpack__timestamp__t">mpack_timestamp_t</a>&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a timestamp. </p>
<dl class="section note"><dt>Note</dt><dd>This requires <a class="el" href="group__config.html#gab1d8587f6e314e491c7fdb262f0b2bd1">MPACK_EXTENSIONS</a>. </dd></dl>

</div>
</div>
<a id="ga5d9f083fd8556ba30f93d4ad139d0dad" name="ga5d9f083fd8556ba30f93d4ad139d0dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d9f083fd8556ba30f93d4ad139d0dad">&#9670;&#160;</a></span>mpack_write_true()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_true </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a boolean with value true. </p>

</div>
</div>
<a id="gabfd74ba7f9f7fddb04d5b4fc5775342d" name="gabfd74ba7f9f7fddb04d5b4fc5775342d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfd74ba7f9f7fddb04d5b4fc5775342d">&#9670;&#160;</a></span>mpack_write_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_u16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an 16-bit unsigned integer in the most efficient packing available. </p>

</div>
</div>
<a id="ga6c20b876be3a17487a6de49cf5a29b57" name="ga6c20b876be3a17487a6de49cf5a29b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c20b876be3a17487a6de49cf5a29b57">&#9670;&#160;</a></span>mpack_write_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_u32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an 32-bit unsigned integer in the most efficient packing available. </p>

</div>
</div>
<a id="ga41d333e6d813655b8054c5ec53832c7c" name="ga41d333e6d813655b8054c5ec53832c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41d333e6d813655b8054c5ec53832c7c">&#9670;&#160;</a></span>mpack_write_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_u64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an 64-bit unsigned integer in the most efficient packing available. </p>

</div>
</div>
<a id="ga573a41209a4b9125ee28c19cddef309a" name="ga573a41209a4b9125ee28c19cddef309a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga573a41209a4b9125ee28c19cddef309a">&#9670;&#160;</a></span>mpack_write_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_u8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an 8-bit unsigned integer in the most efficient packing available. </p>

</div>
</div>
<a id="gab2e3cd22bad53b31bed85d7b46d135c9" name="gab2e3cd22bad53b31bed85d7b46d135c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2e3cd22bad53b31bed85d7b46d135c9">&#9670;&#160;</a></span>mpack_write_uint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_uint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an unsigned integer in the most efficient packing available. </p>

</div>
</div>
<a id="ga5284de75985bd7a41997766fdab107f3" name="ga5284de75985bd7a41997766fdab107f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5284de75985bd7a41997766fdab107f3">&#9670;&#160;</a></span>mpack_write_utf8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_utf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a string, ensuring that it is valid UTF-8. </p>
<p >This does not accept any UTF-8 variant such as Modified UTF-8, CESU-8 or WTF-8. Only pure UTF-8 is allowed.</p>
<p >You should not call <a class="el" href="group__writer.html#ga44f9dd4d379b70fb9534cf1e359e3d4a" title="Finishes writing a string.">mpack_finish_str()</a> after calling this; this performs both start and finish.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_invalid</td><td>if the string is not valid UTF-8 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5c82b06ba51952b2c8f6508e69f3bcc5" name="ga5c82b06ba51952b2c8f6508e69f3bcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c82b06ba51952b2c8f6508e69f3bcc5">&#9670;&#160;</a></span>mpack_write_utf8_cstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_utf8_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a null-terminated string, ensuring that it is valid UTF-8. </p>
<p >(The null-terminator is not written.)</p>
<p >This does not accept any UTF-8 variant such as Modified UTF-8, CESU-8 or WTF-8. Only pure UTF-8 is allowed.</p>
<p >You should not call <a class="el" href="group__writer.html#ga44f9dd4d379b70fb9534cf1e359e3d4a" title="Finishes writing a string.">mpack_finish_str()</a> after calling this; this performs both start and finish.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_invalid</td><td>if the string is not valid UTF-8 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2ef20cf65309d8deb6a11f6811c6b639" name="ga2ef20cf65309d8deb6a11f6811c6b639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ef20cf65309d8deb6a11f6811c6b639">&#9670;&#160;</a></span>mpack_write_utf8_cstr_or_nil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_write_utf8_cstr_or_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a null-terminated string ensuring that it is valid UTF-8, or writes nil if the given cstr pointer is NULL. </p>
<p >(The null-terminator is not written.)</p>
<p >This does not accept any UTF-8 variant such as Modified UTF-8, CESU-8 or WTF-8. Only pure UTF-8 is allowed.</p>
<p >You should not call <a class="el" href="group__writer.html#ga44f9dd4d379b70fb9534cf1e359e3d4a" title="Finishes writing a string.">mpack_finish_str()</a> after calling this; this performs both start and finish.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_invalid</td><td>if the string is not valid UTF-8 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga794ca9b6b8191b6615df5f4762e44727" name="ga794ca9b6b8191b6615df5f4762e44727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga794ca9b6b8191b6615df5f4762e44727">&#9670;&#160;</a></span>mpack_writer_buffer_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_writer_buffer_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount of space left in the buffer. </p>
<p >This may be reset after a write if bytes are flushed to an underlying stream. </p>

</div>
</div>
<a id="ga7fb507f2ed3ba3dd1eb9a339d2fcaeb5" name="ga7fb507f2ed3ba3dd1eb9a339d2fcaeb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fb507f2ed3ba3dd1eb9a339d2fcaeb5">&#9670;&#160;</a></span>mpack_writer_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_writer_buffer_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the (current) size of the buffer. </p>
<p >This may change after a write if the flush callback changes the buffer. </p>

</div>
</div>
<a id="ga52d9c903ac8d34d9b789551d83f09a87" name="ga52d9c903ac8d34d9b789551d83f09a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52d9c903ac8d34d9b789551d83f09a87">&#9670;&#160;</a></span>mpack_writer_buffer_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_writer_buffer_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of bytes currently stored in the buffer. </p>
<p >This may be less than the total number of bytes written if bytes have been flushed to an underlying stream. </p>

</div>
</div>
<a id="ga8e559b7e5bf12da56065bcc28fc09120" name="ga8e559b7e5bf12da56065bcc28fc09120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e559b7e5bf12da56065bcc28fc09120">&#9670;&#160;</a></span>mpack_writer_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * mpack_writer_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the custom context for writer callbacks. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#ga64b403d4370a99e063052f7b9188ad0b" title="Sets the custom pointer to pass to the writer callbacks, such as flush or teardown.">mpack_writer_set_context</a> </dd>
<dd>
<a class="el" href="group__writer.html#ga1337e25984152198814d94b8ddf2e1e1" title="Sets the flush function to write out the data when the buffer is full.">mpack_writer_set_flush</a> </dd></dl>

</div>
</div>
<a id="ga1cf5a2d9b687d94f637a36123ef7cec0" name="ga1cf5a2d9b687d94f637a36123ef7cec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cf5a2d9b687d94f637a36123ef7cec0">&#9670;&#160;</a></span>mpack_writer_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> mpack_writer_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleans up the MPack writer, flushing and closing the underlying stream, if any. </p>
<p >Returns the final error state of the writer.</p>
<p >No flushing is performed if the writer is in an error state. The attached teardown function is called whether or not the writer is in an error state.</p>
<p >This will assert in tracking mode if the writer is not in an error state and has any unclosed compound types. If you want to cancel writing in the middle of a document, you need to flag an error on the writer before destroying it (such as mpack_error_data).</p>
<p >Note that a writer may raise an error and call your error handler during the final flush. It is safe to longjmp or throw out of this error handler, but if you do, the writer will not be destroyed, and the teardown function will not be called. You can still get the writer's error state, and you must call <a class="el" href="group__writer.html#ga1cf5a2d9b687d94f637a36123ef7cec0">mpack_writer_destroy()</a> again. (The second call is guaranteed not to call your error handler again since the writer is already in an error state.)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#ga8b406a46d698bfb2e70cefeea5033d9e" title="Sets the error function to call when an error is flagged on the writer.">mpack_writer_set_error_handler</a> </dd>
<dd>
<a class="el" href="group__writer.html#ga1337e25984152198814d94b8ddf2e1e1" title="Sets the flush function to write out the data when the buffer is full.">mpack_writer_set_flush</a> </dd>
<dd>
<a class="el" href="group__writer.html#gaec0ca26b9eeba93fa07cd82eff32d526" title="Sets the teardown function to call when the writer is destroyed.">mpack_writer_set_teardown</a> </dd>
<dd>
<a class="el" href="group__writer.html#gaf90e598304c7e8a423c534a5d554075e" title="Places the writer in the given error state, calling the error callback if one is set.">mpack_writer_flag_error</a> </dd>
<dd>
<a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ae53cbed8fcc42915d71ae37d121b22e8" title="The contained data is not valid.">mpack_error_data</a> </dd></dl>

</div>
</div>
<a id="ga3adcd5dc4478fbd25b5b48a1c93f0597" name="ga3adcd5dc4478fbd25b5b48a1c93f0597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3adcd5dc4478fbd25b5b48a1c93f0597">&#9670;&#160;</a></span>mpack_writer_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> mpack_writer_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the error state of the MPack writer. </p>
<p >If a writer is in an error state, you should discard all data since the last time the error flag was checked. The error flag cannot be cleared. </p>

</div>
</div>
<a id="gaf90e598304c7e8a423c534a5d554075e" name="gaf90e598304c7e8a423c534a5d554075e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf90e598304c7e8a423c534a5d554075e">&#9670;&#160;</a></span>mpack_writer_flag_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_writer_flag_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places the writer in the given error state, calling the error callback if one is set. </p>
<p >This allows you to externally flag errors, for example if you are validating data as you write it, or if you want to cancel writing in the middle of a document. (The writer will assert if you try to destroy it without error and with unclosed compound types. In this case you should flag mpack_error_data before destroying it.)</p>
<p >If the writer is already in an error state, this call is ignored and no error callback is called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#ga1cf5a2d9b687d94f637a36123ef7cec0" title="Cleans up the MPack writer, flushing and closing the underlying stream, if any.">mpack_writer_destroy</a> </dd>
<dd>
<a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ae53cbed8fcc42915d71ae37d121b22e8" title="The contained data is not valid.">mpack_error_data</a> </dd></dl>

</div>
</div>
<a id="ga0e8649525969ae318bf0f125d8b55f50" name="ga0e8649525969ae318bf0f125d8b55f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e8649525969ae318bf0f125d8b55f50">&#9670;&#160;</a></span>mpack_writer_flush_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_writer_flush_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes any buffered data to the underlying stream. </p>
<p >If the writer is connected to a socket and you are keeping it open, you will want to call this after writing a message (or set of messages) so that the data is actually sent.</p>
<p >It is not necessary to call this if you are not keeping the writer open afterwards. You can just call <code><a class="el" href="group__writer.html#ga1cf5a2d9b687d94f637a36123ef7cec0" title="Cleans up the MPack writer, flushing and closing the underlying stream, if any.">mpack_writer_destroy()</a></code> and it will flush before cleaning up.</p>
<p >This will assert if no flush function is assigned to the writer.</p>
<p >If write tracking is enabled, this will break and flag <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ae35afae5a24379821fa74315be1aa0d6">mpack_error_bug</a> if the writer has any open compound types, ensuring that no compound types are still open. This prevents a "missing
finish" bug from causing a never-ending message. </p>

</div>
</div>
<a id="gabf46d5fd103d44d03c412cb7bb52e2d0" name="gabf46d5fd103d44d03c412cb7bb52e2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf46d5fd103d44d03c412cb7bb52e2d0">&#9670;&#160;</a></span>mpack_writer_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_writer_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an MPack writer with the given buffer. </p>
<p >The writer does not assume ownership of the buffer.</p>
<p >Trying to write past the end of the buffer will result in mpack_error_too_big unless a flush function is set with <a class="el" href="group__writer.html#ga1337e25984152198814d94b8ddf2e1e1" title="Sets the flush function to write out the data when the buffer is full.">mpack_writer_set_flush()</a>. To use the data without flushing, call <a class="el" href="group__writer.html#ga52d9c903ac8d34d9b789551d83f09a87" title="Returns the number of bytes currently stored in the buffer.">mpack_writer_buffer_used()</a> to determine the number of bytes written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writer</td><td>The MPack writer. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer into which to write MessagePack data. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab3c8d9ebe78513a17a38af28f387d169" name="gab3c8d9ebe78513a17a38af28f387d169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3c8d9ebe78513a17a38af28f387d169">&#9670;&#160;</a></span>mpack_writer_init_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_writer_init_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an MPack writer directly into an error state. </p>
<p >Use this if you are writing a wrapper to <a class="el" href="group__writer.html#gabf46d5fd103d44d03c412cb7bb52e2d0" title="Initializes an MPack writer with the given buffer.">mpack_writer_init()</a> which can fail its setup. </p>

</div>
</div>
<a id="gafb05fb381c28a36b8917a1697e5ab611" name="gafb05fb381c28a36b8917a1697e5ab611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb05fb381c28a36b8917a1697e5ab611">&#9670;&#160;</a></span>mpack_writer_init_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_writer_init_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>Renamed to <a class="el" href="group__writer.html#ga80c2f57160ec9e0efe02f2b3820a8661" title="Initializes an MPack writer that writes to a file.">mpack_writer_init_filename()</a>. </dd></dl>

</div>
</div>
<a id="ga80c2f57160ec9e0efe02f2b3820a8661" name="ga80c2f57160ec9e0efe02f2b3820a8661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80c2f57160ec9e0efe02f2b3820a8661">&#9670;&#160;</a></span>mpack_writer_init_filename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_writer_init_filename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an MPack writer that writes to a file. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_memory</td><td>if allocation fails </td></tr>
    <tr><td class="paramname">mpack_error_io</td><td>if the file cannot be opened </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0aa3b265fb5ece9c4cba0f2b1bfbdb53" name="ga0aa3b265fb5ece9c4cba0f2b1bfbdb53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aa3b265fb5ece9c4cba0f2b1bfbdb53">&#9670;&#160;</a></span>mpack_writer_init_growable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_writer_init_growable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an MPack writer using a growable buffer. </p>
<p >The data is placed in the given data pointer if and when the writer is destroyed without error. The data pointer is NULL during writing, and will remain NULL if an error occurs.</p>
<p >The allocated data must be freed with <a class="el" href="group__config.html#ga298d7c2e4093bcfe361088df9e35956a" title="Defines the memory free function used by MPack.">MPACK_FREE()</a> (or simply free() if MPack's allocator hasn't been customized.)</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_memory</td><td>if the buffer fails to grow when flushing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writer</td><td>The MPack writer. </td></tr>
    <tr><td class="paramname">data</td><td>Where to place the allocated data. </td></tr>
    <tr><td class="paramname">size</td><td>Where to write the size of the data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe9a212641a4edd010ccdd9ecf888485" name="gabe9a212641a4edd010ccdd9ecf888485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe9a212641a4edd010ccdd9ecf888485">&#9670;&#160;</a></span>mpack_writer_init_stdfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_writer_init_stdfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stdfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>close_when_done</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an MPack writer that writes to a libc FILE. </p>
<p >This can be used to write to stdout or stderr, or to a file opened separately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writer</td><td>The MPack writer. </td></tr>
    <tr><td class="paramname">stdfile</td><td>The FILE. </td></tr>
    <tr><td class="paramname">close_when_done</td><td>If true, fclose() will be called on the FILE when it is no longer needed. If false, the file will not be flushed or closed when writing is done.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The writer is buffered. If you want to write other data to the FILE in between messages, you must flush it first.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#ga0e8649525969ae318bf0f125d8b55f50" title="Flushes any buffered data to the underlying stream.">mpack_writer_flush_message</a> </dd></dl>

</div>
</div>
<a id="ga64b403d4370a99e063052f7b9188ad0b" name="ga64b403d4370a99e063052f7b9188ad0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64b403d4370a99e063052f7b9188ad0b">&#9670;&#160;</a></span>mpack_writer_set_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_writer_set_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the custom pointer to pass to the writer callbacks, such as flush or teardown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writer</td><td>The MPack writer. </td></tr>
    <tr><td class="paramname">context</td><td>User data to pass to the writer callbacks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#ga8e559b7e5bf12da56065bcc28fc09120" title="Returns the custom context for writer callbacks.">mpack_writer_context()</a> </dd></dl>

</div>
</div>
<a id="ga8b406a46d698bfb2e70cefeea5033d9e" name="ga8b406a46d698bfb2e70cefeea5033d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b406a46d698bfb2e70cefeea5033d9e">&#9670;&#160;</a></span>mpack_writer_set_error_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_writer_set_error_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__writer.html#ga65d410be0305a59ec15cfe700f8b036a">mpack_writer_error_t</a>&#160;</td>
          <td class="paramname"><em>error_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the error function to call when an error is flagged on the writer. </p>
<p >This should normally be used with <a class="el" href="group__writer.html#ga64b403d4370a99e063052f7b9188ad0b" title="Sets the custom pointer to pass to the writer callbacks, such as flush or teardown.">mpack_writer_set_context()</a> to register a custom pointer to pass to the error function.</p>
<p >See the definition of mpack_writer_error_t for more information about what you can do from an error callback.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#ga65d410be0305a59ec15cfe700f8b036a" title="An error handler function to be called when an error is flagged on the writer.">mpack_writer_error_t</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writer</td><td>The MPack writer. </td></tr>
    <tr><td class="paramname">error_fn</td><td>The function to call when an error is flagged on the writer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1337e25984152198814d94b8ddf2e1e1" name="ga1337e25984152198814d94b8ddf2e1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1337e25984152198814d94b8ddf2e1e1">&#9670;&#160;</a></span>mpack_writer_set_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_writer_set_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__writer.html#gad5749babfacaa707cbaff06bcbc790a5">mpack_writer_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the flush function to write out the data when the buffer is full. </p>
<p >If no flush function is used, trying to write past the end of the buffer will result in mpack_error_too_big.</p>
<p >This should normally be used with <a class="el" href="group__writer.html#ga64b403d4370a99e063052f7b9188ad0b" title="Sets the custom pointer to pass to the writer callbacks, such as flush or teardown.">mpack_writer_set_context()</a> to register a custom pointer to pass to the flush function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writer</td><td>The MPack writer. </td></tr>
    <tr><td class="paramname">flush</td><td>The function to write out data from the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#ga8e559b7e5bf12da56065bcc28fc09120" title="Returns the custom context for writer callbacks.">mpack_writer_context()</a> </dd></dl>

</div>
</div>
<a id="gaec0ca26b9eeba93fa07cd82eff32d526" name="gaec0ca26b9eeba93fa07cd82eff32d526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec0ca26b9eeba93fa07cd82eff32d526">&#9670;&#160;</a></span>mpack_writer_set_teardown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_writer_set_teardown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__writer.html#ga97ccab59b332d882d386c10b241eb888">mpack_writer_teardown_t</a>&#160;</td>
          <td class="paramname"><em>teardown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the teardown function to call when the writer is destroyed. </p>
<p >This should normally be used with <a class="el" href="group__writer.html#ga64b403d4370a99e063052f7b9188ad0b" title="Sets the custom pointer to pass to the writer callbacks, such as flush or teardown.">mpack_writer_set_context()</a> to register a custom pointer to pass to the teardown function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writer</td><td>The MPack writer. </td></tr>
    <tr><td class="paramname">teardown</td><td>The function to call when the writer is destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga17f828f0b8e560dfdc7cc635f462f6f7" name="ga17f828f0b8e560dfdc7cc635f462f6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17f828f0b8e560dfdc7cc635f462f6f7">&#9670;&#160;</a></span>mpack_writer_set_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_writer_set_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#gaba84f7d6b203a1f51f2a3e10c80318e2">mpack_version_t</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the version of the MessagePack spec that will be generated. </p>
<p >This can be used to interface with older libraries that do not support the newest MessagePack features (such as the <code>str8</code> type.)</p>
<dl class="section note"><dt>Note</dt><dd>This requires <a class="el" href="group__config.html#ga3b7bc28af1393f6ab472f4595e29387b">MPACK_COMPATIBILITY</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
