<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MPack: Reader API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-mpack-css.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MPack<span id="projectnumber">&#160;1.1.1</span>
   </div>
   <div id="projectbrief">A C encoding/decoding library for the MessagePack serialization format.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle"><div class="title">Reader API</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p >The MPack Reader API contains functions for imperatively reading dynamically typed data from a MessagePack stream. </p>
<p >See <a class="el" href="md_docs_reader.html">Using the Reader API</a> for examples.</p>
<dl class="section note"><dt>Note</dt><dd>If you are not writing code for an embedded device (or otherwise do not need maximum performance with minimal memory usage), you should not use this. You probably want to use the <a class="el" href="group__node.html">Node API</a> instead.</dd></dl>
<p>This forms the basis of the <a class="el" href="group__expect.html">Expect API</a>, which can be used to interpret the stream of elements in expected types and value ranges. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac8b222eb575099fa92f086eeeb8dc83f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gac8b222eb575099fa92f086eeeb8dc83f">MPACK_READER_MINIMUM_BUFFER_SIZE</a>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:gac8b222eb575099fa92f086eeeb8dc83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum buffer size for a reader with a fill function.  <a href="group__reader.html#gac8b222eb575099fa92f086eeeb8dc83f">More...</a><br /></td></tr>
<tr class="separator:gac8b222eb575099fa92f086eeeb8dc83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga799a3f21adc8e229c6040ab42d90bef3"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga799a3f21adc8e229c6040ab42d90bef3">mpack_reader_error_t</a>) (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td></tr>
<tr class="memdesc:ga799a3f21adc8e229c6040ab42d90bef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error handler function to be called when an error is flagged on the reader.  <a href="group__reader.html#ga799a3f21adc8e229c6040ab42d90bef3">More...</a><br /></td></tr>
<tr class="separator:ga799a3f21adc8e229c6040ab42d90bef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97503ca06d41d58c60226b2732661eda"><td class="memItemLeft" align="right" valign="top">typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga97503ca06d41d58c60226b2732661eda">mpack_reader_fill_t</a>) (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *buffer, size_t count)</td></tr>
<tr class="memdesc:ga97503ca06d41d58c60226b2732661eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MPack reader's fill function.  <a href="group__reader.html#ga97503ca06d41d58c60226b2732661eda">More...</a><br /></td></tr>
<tr class="separator:ga97503ca06d41d58c60226b2732661eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a0b236c7befe9cb959dabce15acd23b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga6a0b236c7befe9cb959dabce15acd23b">mpack_reader_skip_t</a>) (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t count)</td></tr>
<tr class="memdesc:ga6a0b236c7befe9cb959dabce15acd23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MPack reader's skip function.  <a href="group__reader.html#ga6a0b236c7befe9cb959dabce15acd23b">More...</a><br /></td></tr>
<tr class="separator:ga6a0b236c7befe9cb959dabce15acd23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee791c36a15344b9e57edae160c86615"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a></td></tr>
<tr class="memdesc:gaee791c36a15344b9e57edae160c86615"><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffered MessagePack decoder.  <a href="group__reader.html#gaee791c36a15344b9e57edae160c86615">More...</a><br /></td></tr>
<tr class="separator:gaee791c36a15344b9e57edae160c86615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadda6baaccdcf0ad9c5e212be9992cf5b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gadda6baaccdcf0ad9c5e212be9992cf5b">mpack_reader_teardown_t</a>) (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gadda6baaccdcf0ad9c5e212be9992cf5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A teardown function to be called when the reader is destroyed.  <a href="group__reader.html#gadda6baaccdcf0ad9c5e212be9992cf5b">More...</a><br /></td></tr>
<tr class="separator:gadda6baaccdcf0ad9c5e212be9992cf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Lifecycle Functions</h2></td></tr>
<tr class="memitem:ga1d79c00c6c013b879b164c26753b3e83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga1d79c00c6c013b879b164c26753b3e83">mpack_reader_init</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *buffer, size_t size, size_t count)</td></tr>
<tr class="memdesc:ga1d79c00c6c013b879b164c26753b3e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an MPack reader with the given buffer.  <a href="group__reader.html#ga1d79c00c6c013b879b164c26753b3e83">More...</a><br /></td></tr>
<tr class="separator:ga1d79c00c6c013b879b164c26753b3e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga729bf4c0a79516e97a65d2e278f336e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga729bf4c0a79516e97a65d2e278f336e0">mpack_reader_init_error</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td></tr>
<tr class="memdesc:ga729bf4c0a79516e97a65d2e278f336e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an MPack reader directly into an error state.  <a href="group__reader.html#ga729bf4c0a79516e97a65d2e278f336e0">More...</a><br /></td></tr>
<tr class="separator:ga729bf4c0a79516e97a65d2e278f336e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18f41d6786155f265769351ef550e331"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga18f41d6786155f265769351ef550e331">mpack_reader_init_data</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, const char *data, size_t count)</td></tr>
<tr class="memdesc:ga18f41d6786155f265769351ef550e331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an MPack reader to parse a pre-loaded contiguous chunk of data.  <a href="group__reader.html#ga18f41d6786155f265769351ef550e331">More...</a><br /></td></tr>
<tr class="separator:ga18f41d6786155f265769351ef550e331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf19892a6dd87d86bdd02646528964ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gadf19892a6dd87d86bdd02646528964ff">mpack_reader_init_filename</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, const char *filename)</td></tr>
<tr class="memdesc:gadf19892a6dd87d86bdd02646528964ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an MPack reader that reads from a file.  <a href="group__reader.html#gadf19892a6dd87d86bdd02646528964ff">More...</a><br /></td></tr>
<tr class="separator:gadf19892a6dd87d86bdd02646528964ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga957b5be20debe9f3b81b629478bda0f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga957b5be20debe9f3b81b629478bda0f5">mpack_reader_init_file</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, const char *filename)</td></tr>
<tr class="memdesc:ga957b5be20debe9f3b81b629478bda0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated.  <a href="group__reader.html#ga957b5be20debe9f3b81b629478bda0f5">More...</a><br /></td></tr>
<tr class="separator:ga957b5be20debe9f3b81b629478bda0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97127332a566ac5fd7da541cad50bac4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga97127332a566ac5fd7da541cad50bac4">mpack_reader_init_stdfile</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, FILE *stdfile, bool close_when_done)</td></tr>
<tr class="memdesc:ga97127332a566ac5fd7da541cad50bac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an MPack reader that reads from a libc FILE.  <a href="group__reader.html#ga97127332a566ac5fd7da541cad50bac4">More...</a><br /></td></tr>
<tr class="separator:ga97127332a566ac5fd7da541cad50bac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac04666405e21eea6e8819182571f0d20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gac04666405e21eea6e8819182571f0d20">mpack_reader_destroy</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gac04666405e21eea6e8819182571f0d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up the MPack reader, ensuring that all compound elements have been completely read.  <a href="group__reader.html#gac04666405e21eea6e8819182571f0d20">More...</a><br /></td></tr>
<tr class="separator:gac04666405e21eea6e8819182571f0d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3950ce57f3f125755cc1cefd1f54e149"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga3950ce57f3f125755cc1cefd1f54e149">mpack_reader_init_stack</a>(reader)</td></tr>
<tr class="memdesc:ga3950ce57f3f125755cc1cefd1f54e149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an MPack reader using stack space as a buffer.  <a href="group__reader.html#ga3950ce57f3f125755cc1cefd1f54e149">More...</a><br /></td></tr>
<tr class="separator:ga3950ce57f3f125755cc1cefd1f54e149"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Callbacks</h2></td></tr>
<tr class="memitem:gafc76e77e7431f13ba7ff6a6a83fffe07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gafc76e77e7431f13ba7ff6a6a83fffe07">mpack_reader_set_context</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, void *context)</td></tr>
<tr class="memdesc:gafc76e77e7431f13ba7ff6a6a83fffe07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the custom pointer to pass to the reader callbacks, such as fill or teardown.  <a href="group__reader.html#gafc76e77e7431f13ba7ff6a6a83fffe07">More...</a><br /></td></tr>
<tr class="separator:gafc76e77e7431f13ba7ff6a6a83fffe07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee1c031416ba0ee0d516aeb9e1858fce"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaee1c031416ba0ee0d516aeb9e1858fce">mpack_reader_context</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gaee1c031416ba0ee0d516aeb9e1858fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the custom context for reader callbacks.  <a href="group__reader.html#gaee1c031416ba0ee0d516aeb9e1858fce">More...</a><br /></td></tr>
<tr class="separator:gaee1c031416ba0ee0d516aeb9e1858fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4eab68e9d1751ff9c6c853d563d9a0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaf4eab68e9d1751ff9c6c853d563d9a0e">mpack_reader_set_fill</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__reader.html#ga97503ca06d41d58c60226b2732661eda">mpack_reader_fill_t</a> fill)</td></tr>
<tr class="memdesc:gaf4eab68e9d1751ff9c6c853d563d9a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fill function to refill the data buffer when it runs out of data.  <a href="group__reader.html#gaf4eab68e9d1751ff9c6c853d563d9a0e">More...</a><br /></td></tr>
<tr class="separator:gaf4eab68e9d1751ff9c6c853d563d9a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa925114414e77ff809fcaaba399c8162"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaa925114414e77ff809fcaaba399c8162">mpack_reader_set_skip</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__reader.html#ga6a0b236c7befe9cb959dabce15acd23b">mpack_reader_skip_t</a> skip)</td></tr>
<tr class="memdesc:gaa925114414e77ff809fcaaba399c8162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the skip function to discard bytes from the source stream.  <a href="group__reader.html#gaa925114414e77ff809fcaaba399c8162">More...</a><br /></td></tr>
<tr class="separator:gaa925114414e77ff809fcaaba399c8162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga926fbc6c3e5d048001dc070c8dc015ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga926fbc6c3e5d048001dc070c8dc015ed">mpack_reader_set_error_handler</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__reader.html#ga799a3f21adc8e229c6040ab42d90bef3">mpack_reader_error_t</a> error_fn)</td></tr>
<tr class="memdesc:ga926fbc6c3e5d048001dc070c8dc015ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the error function to call when an error is flagged on the reader.  <a href="group__reader.html#ga926fbc6c3e5d048001dc070c8dc015ed">More...</a><br /></td></tr>
<tr class="separator:ga926fbc6c3e5d048001dc070c8dc015ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad04ce10afce7422697d861f46e5aee86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gad04ce10afce7422697d861f46e5aee86">mpack_reader_set_teardown</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__reader.html#gadda6baaccdcf0ad9c5e212be9992cf5b">mpack_reader_teardown_t</a> teardown)</td></tr>
<tr class="memdesc:gad04ce10afce7422697d861f46e5aee86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the teardown function to call when the reader is destroyed.  <a href="group__reader.html#gad04ce10afce7422697d861f46e5aee86">More...</a><br /></td></tr>
<tr class="separator:gad04ce10afce7422697d861f46e5aee86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Core Reader Functions</h2></td></tr>
<tr class="memitem:ga79050efd2a581e8216f58d4946e7abc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga79050efd2a581e8216f58d4946e7abc2">mpack_reader_error</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga79050efd2a581e8216f58d4946e7abc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the error state of the MPack reader.  <a href="group__reader.html#ga79050efd2a581e8216f58d4946e7abc2">More...</a><br /></td></tr>
<tr class="separator:ga79050efd2a581e8216f58d4946e7abc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c45c2e0592f16ae671cd509d8d8c512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga5c45c2e0592f16ae671cd509d8d8c512">mpack_reader_flag_error</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td></tr>
<tr class="memdesc:ga5c45c2e0592f16ae671cd509d8d8c512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places the reader in the given error state, calling the error callback if one is set.  <a href="group__reader.html#ga5c45c2e0592f16ae671cd509d8d8c512">More...</a><br /></td></tr>
<tr class="separator:ga5c45c2e0592f16ae671cd509d8d8c512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09da1e5abbce2b9f7f70d82924eefa3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga09da1e5abbce2b9f7f70d82924eefa3f">mpack_reader_flag_if_error</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td></tr>
<tr class="memdesc:ga09da1e5abbce2b9f7f70d82924eefa3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places the reader in the given error state if the given error is not mpack_ok, returning the resulting error state of the reader.  <a href="group__reader.html#ga09da1e5abbce2b9f7f70d82924eefa3f">More...</a><br /></td></tr>
<tr class="separator:ga09da1e5abbce2b9f7f70d82924eefa3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga291a38358bde6992b16edda81f2fcf45"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga291a38358bde6992b16edda81f2fcf45">mpack_reader_remaining</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, const char **data)</td></tr>
<tr class="memdesc:ga291a38358bde6992b16edda81f2fcf45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns bytes left in the reader's buffer.  <a href="group__reader.html#ga291a38358bde6992b16edda81f2fcf45">More...</a><br /></td></tr>
<tr class="separator:ga291a38358bde6992b16edda81f2fcf45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70c00ecaf381e9711f6c1d0fa92f0c2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga008da69ac6b5582a893f2d2ffd37f4ac">mpack_tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga70c00ecaf381e9711f6c1d0fa92f0c2f">mpack_read_tag</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga70c00ecaf381e9711f6c1d0fa92f0c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a MessagePack object header (an MPack tag.)  <a href="group__reader.html#ga70c00ecaf381e9711f6c1d0fa92f0c2f">More...</a><br /></td></tr>
<tr class="separator:ga70c00ecaf381e9711f6c1d0fa92f0c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga397a8d0738b8d68753a470a988b813aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga008da69ac6b5582a893f2d2ffd37f4ac">mpack_tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga397a8d0738b8d68753a470a988b813aa">mpack_peek_tag</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga397a8d0738b8d68753a470a988b813aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the next MessagePack object header (an MPack tag) without advancing the reader.  <a href="group__reader.html#ga397a8d0738b8d68753a470a988b813aa">More...</a><br /></td></tr>
<tr class="separator:ga397a8d0738b8d68753a470a988b813aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ec982b75a30187d9f94831f2e4b20a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga2ec982b75a30187d9f94831f2e4b20a0">mpack_done_type</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__common.html#ga22f03cf1240d5a917e1b3e7be8ab327e">mpack_type_t</a> type)</td></tr>
<tr class="memdesc:ga2ec982b75a30187d9f94831f2e4b20a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes reading the given type.  <a href="group__reader.html#ga2ec982b75a30187d9f94831f2e4b20a0">More...</a><br /></td></tr>
<tr class="separator:ga2ec982b75a30187d9f94831f2e4b20a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddae460657b9a26207ed34352bff0b06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">mpack_done_array</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gaddae460657b9a26207ed34352bff0b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes reading an array.  <a href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">More...</a><br /></td></tr>
<tr class="separator:gaddae460657b9a26207ed34352bff0b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86165fc780e7adef09f4b45aee54842a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga86165fc780e7adef09f4b45aee54842a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes reading a map.  <a href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">More...</a><br /></td></tr>
<tr class="separator:ga86165fc780e7adef09f4b45aee54842a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaad37015e0c53704d9356de06b493de6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaaad37015e0c53704d9356de06b493de6">mpack_done_str</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gaaad37015e0c53704d9356de06b493de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes reading a string.  <a href="group__reader.html#gaaad37015e0c53704d9356de06b493de6">More...</a><br /></td></tr>
<tr class="separator:gaaad37015e0c53704d9356de06b493de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4676c4b0761de4f864fd81c347a15a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaa4676c4b0761de4f864fd81c347a15a0">mpack_done_bin</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gaa4676c4b0761de4f864fd81c347a15a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes reading a binary data blob.  <a href="group__reader.html#gaa4676c4b0761de4f864fd81c347a15a0">More...</a><br /></td></tr>
<tr class="separator:gaa4676c4b0761de4f864fd81c347a15a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ebed90f6fe9c1d324256d827032702b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga5ebed90f6fe9c1d324256d827032702b">mpack_done_ext</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga5ebed90f6fe9c1d324256d827032702b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes reading an extended type binary data blob.  <a href="group__reader.html#ga5ebed90f6fe9c1d324256d827032702b">More...</a><br /></td></tr>
<tr class="separator:ga5ebed90f6fe9c1d324256d827032702b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga438bb2b85fbbd06cd8f10d5c8079427e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga438bb2b85fbbd06cd8f10d5c8079427e">mpack_discard</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga438bb2b85fbbd06cd8f10d5c8079427e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and discards the next object.  <a href="group__reader.html#ga438bb2b85fbbd06cd8f10d5c8079427e">More...</a><br /></td></tr>
<tr class="separator:ga438bb2b85fbbd06cd8f10d5c8079427e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">String and Data Functions</h2></td></tr>
<tr class="memitem:ga0c7e1dd2be56ce3d596326c4463e7229"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga0c7e1dd2be56ce3d596326c4463e7229">mpack_skip_bytes</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t count)</td></tr>
<tr class="memdesc:ga0c7e1dd2be56ce3d596326c4463e7229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips bytes from the underlying stream.  <a href="group__reader.html#ga0c7e1dd2be56ce3d596326c4463e7229">More...</a><br /></td></tr>
<tr class="separator:ga0c7e1dd2be56ce3d596326c4463e7229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb91e8d4e2a7b7f6562d8bbb7400275c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c">mpack_read_bytes</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *p, size_t count)</td></tr>
<tr class="memdesc:gaeb91e8d4e2a7b7f6562d8bbb7400275c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads bytes from a string, binary blob or extension object, copying them into the given buffer.  <a href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c">More...</a><br /></td></tr>
<tr class="separator:gaeb91e8d4e2a7b7f6562d8bbb7400275c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee9d5bd9ec3d123dac575651f0ec2186"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaee9d5bd9ec3d123dac575651f0ec2186">mpack_read_utf8</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *p, size_t byte_count)</td></tr>
<tr class="memdesc:gaee9d5bd9ec3d123dac575651f0ec2186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads bytes from a string, ensures that the string is valid UTF-8, and copies the bytes into the given buffer.  <a href="group__reader.html#gaee9d5bd9ec3d123dac575651f0ec2186">More...</a><br /></td></tr>
<tr class="separator:gaee9d5bd9ec3d123dac575651f0ec2186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga628cbed1d2ffac977fed3b9ef5bf0fea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga628cbed1d2ffac977fed3b9ef5bf0fea">mpack_read_cstr</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *buf, size_t buffer_size, size_t byte_count)</td></tr>
<tr class="memdesc:ga628cbed1d2ffac977fed3b9ef5bf0fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads bytes from a string, ensures that the string contains no NUL bytes, copies the bytes into the given buffer and adds a null-terminator.  <a href="group__reader.html#ga628cbed1d2ffac977fed3b9ef5bf0fea">More...</a><br /></td></tr>
<tr class="separator:ga628cbed1d2ffac977fed3b9ef5bf0fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad053c4bccda721a25c48d66fa0f211cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gad053c4bccda721a25c48d66fa0f211cf">mpack_read_utf8_cstr</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *buf, size_t buffer_size, size_t byte_count)</td></tr>
<tr class="memdesc:gad053c4bccda721a25c48d66fa0f211cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads bytes from a string, ensures that the string is valid UTF-8 with no NUL bytes, copies the bytes into the given buffer and adds a null-terminator.  <a href="group__reader.html#gad053c4bccda721a25c48d66fa0f211cf">More...</a><br /></td></tr>
<tr class="separator:gad053c4bccda721a25c48d66fa0f211cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga539b6fe809908faf0f2e030b07efa8d8"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga539b6fe809908faf0f2e030b07efa8d8">mpack_read_bytes_alloc</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t count)</td></tr>
<tr class="memdesc:ga539b6fe809908faf0f2e030b07efa8d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads bytes from a string, binary blob or extension object, allocating storage for them and returning the allocated pointer.  <a href="group__reader.html#ga539b6fe809908faf0f2e030b07efa8d8">More...</a><br /></td></tr>
<tr class="separator:ga539b6fe809908faf0f2e030b07efa8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4777ac528d7abbc7313469737546e1a4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga4777ac528d7abbc7313469737546e1a4">mpack_read_bytes_inplace</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t count)</td></tr>
<tr class="memdesc:ga4777ac528d7abbc7313469737546e1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads bytes from a string, binary blob or extension object in-place in the buffer.  <a href="group__reader.html#ga4777ac528d7abbc7313469737546e1a4">More...</a><br /></td></tr>
<tr class="separator:ga4777ac528d7abbc7313469737546e1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76af5d206358a692b2aeeec6dbeff29c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga76af5d206358a692b2aeeec6dbeff29c">mpack_read_utf8_inplace</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t count)</td></tr>
<tr class="memdesc:ga76af5d206358a692b2aeeec6dbeff29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads bytes from a string in-place in the buffer and ensures they are valid UTF-8.  <a href="group__reader.html#ga76af5d206358a692b2aeeec6dbeff29c">More...</a><br /></td></tr>
<tr class="separator:ga76af5d206358a692b2aeeec6dbeff29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa69e23a50f63c84b45f9247db9c22ad0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaa69e23a50f63c84b45f9247db9c22ad0">mpack_should_read_bytes_inplace</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t count)</td></tr>
<tr class="memdesc:gaa69e23a50f63c84b45f9247db9c22ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if it's a good idea to read the given number of bytes in-place.  <a href="group__reader.html#gaa69e23a50f63c84b45f9247db9c22ad0">More...</a><br /></td></tr>
<tr class="separator:gaa69e23a50f63c84b45f9247db9c22ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd0162db0e7e1d0e01a5b5cd1759d1b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#structmpack__timestamp__t">mpack_timestamp_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gabd0162db0e7e1d0e01a5b5cd1759d1b5">mpack_read_timestamp</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t size)</td></tr>
<tr class="memdesc:gabd0162db0e7e1d0e01a5b5cd1759d1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a timestamp contained in an ext object of the given size, closing the ext type.  <a href="group__reader.html#gabd0162db0e7e1d0e01a5b5cd1759d1b5">More...</a><br /></td></tr>
<tr class="separator:gabd0162db0e7e1d0e01a5b5cd1759d1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga3950ce57f3f125755cc1cefd1f54e149" name="ga3950ce57f3f125755cc1cefd1f54e149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3950ce57f3f125755cc1cefd1f54e149">&#9670;&#160;</a></span>mpack_reader_init_stack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mpack_reader_init_stack</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reader</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an MPack reader using stack space as a buffer. </p>
<p >A fill function should be added to the reader to fill the buffer.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#gaf4eab68e9d1751ff9c6c853d563d9a0e" title="Sets the fill function to refill the data buffer when it runs out of data.">mpack_reader_set_fill</a> </dd></dl>

</div>
</div>
<a id="gac8b222eb575099fa92f086eeeb8dc83f" name="gac8b222eb575099fa92f086eeeb8dc83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8b222eb575099fa92f086eeeb8dc83f">&#9670;&#160;</a></span>MPACK_READER_MINIMUM_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MPACK_READER_MINIMUM_BUFFER_SIZE&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The minimum buffer size for a reader with a fill function. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga799a3f21adc8e229c6040ab42d90bef3" name="ga799a3f21adc8e229c6040ab42d90bef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga799a3f21adc8e229c6040ab42d90bef3">&#9670;&#160;</a></span>mpack_reader_error_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mpack_reader_error_t) (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An error handler function to be called when an error is flagged on the reader. </p>
<p >The error handler will only be called once on the first error flagged; any subsequent reads and errors are ignored, and the reader is permanently in that error state.</p>
<p >MPack is safe against non-local jumps out of error handler callbacks. This means you are allowed to longjmp or throw an exception (in C++, Objective-C, or with SEH) out of this callback.</p>
<p >Bear in mind when using longjmp that local non-volatile variables that have changed are undefined when setjmp() returns, so you can't put the reader on the stack in the same activation frame as the setjmp without declaring it volatile.</p>
<p >You must still eventually destroy the reader. It is not destroyed automatically when an error is flagged. It is safe to destroy the reader within this error callback, but you will either need to perform a non-local jump, or store something in your context to identify that the reader is destroyed since any future accesses to it cause undefined behavior. </p>

</div>
</div>
<a id="ga97503ca06d41d58c60226b2732661eda" name="ga97503ca06d41d58c60226b2732661eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97503ca06d41d58c60226b2732661eda">&#9670;&#160;</a></span>mpack_reader_fill_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(* mpack_reader_fill_t) (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *buffer, size_t count)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The MPack reader's fill function. </p>
<p >It should fill the buffer with at least one byte and at most the given <code>count</code>, returning the number of bytes written to the buffer.</p>
<p >In case of error, it should flag an appropriate error on the reader (usually <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4a6581b50527f1c278f852c91bea70f847">mpack_error_io</a>), or simply return zero. If zero is returned, mpack_error_io is raised.</p>
<dl class="section note"><dt>Note</dt><dd>When reading from a stream, you should only copy and return the bytes that are immediately available. It is always safe to return less than the requested count as long as some non-zero number of bytes are read; if more bytes are needed, the read function will simply be called again.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#gaee1c031416ba0ee0d516aeb9e1858fce" title="Returns the custom context for reader callbacks.">mpack_reader_context()</a> </dd></dl>

</div>
</div>
<a id="ga6a0b236c7befe9cb959dabce15acd23b" name="ga6a0b236c7befe9cb959dabce15acd23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a0b236c7befe9cb959dabce15acd23b">&#9670;&#160;</a></span>mpack_reader_skip_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mpack_reader_skip_t) (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t count)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The MPack reader's skip function. </p>
<p >It should discard the given number of bytes from the source (for example by seeking forward.)</p>
<p >In case of error, it should flag an appropriate error on the reader.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#gaee1c031416ba0ee0d516aeb9e1858fce" title="Returns the custom context for reader callbacks.">mpack_reader_context()</a> </dd></dl>

</div>
</div>
<a id="gaee791c36a15344b9e57edae160c86615" name="gaee791c36a15344b9e57edae160c86615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee791c36a15344b9e57edae160c86615">&#9670;&#160;</a></span>mpack_reader_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> <a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A buffered MessagePack decoder. </p>
<p >The decoder wraps an existing buffer and, optionally, a fill function. This allows efficiently decoding data from existing memory buffers, files, streams, etc.</p>
<p >All read operations are synchronous; they will block until the requested data is fully read, or an error occurs.</p>
<p >This structure is opaque; its fields should not be accessed outside of MPack. </p>

</div>
</div>
<a id="gadda6baaccdcf0ad9c5e212be9992cf5b" name="gadda6baaccdcf0ad9c5e212be9992cf5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadda6baaccdcf0ad9c5e212be9992cf5b">&#9670;&#160;</a></span>mpack_reader_teardown_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mpack_reader_teardown_t) (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A teardown function to be called when the reader is destroyed. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga438bb2b85fbbd06cd8f10d5c8079427e" name="ga438bb2b85fbbd06cd8f10d5c8079427e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga438bb2b85fbbd06cd8f10d5c8079427e">&#9670;&#160;</a></span>mpack_discard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_discard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads and discards the next object. </p>
<p >This will read and discard all contained data as well if it is a compound type. </p>

</div>
</div>
<a id="gaddae460657b9a26207ed34352bff0b06" name="gaddae460657b9a26207ed34352bff0b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddae460657b9a26207ed34352bff0b06">&#9670;&#160;</a></span>mpack_done_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_done_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes reading an array. </p>
<p >This will track reads to ensure that the correct number of elements are read. </p>

</div>
</div>
<a id="gaa4676c4b0761de4f864fd81c347a15a0" name="gaa4676c4b0761de4f864fd81c347a15a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4676c4b0761de4f864fd81c347a15a0">&#9670;&#160;</a></span>mpack_done_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mpack_done_bin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes reading a binary data blob. </p>
<p >This will track reads to ensure that the correct number of bytes are read. </p>

</div>
</div>
<a id="ga5ebed90f6fe9c1d324256d827032702b" name="ga5ebed90f6fe9c1d324256d827032702b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ebed90f6fe9c1d324256d827032702b">&#9670;&#160;</a></span>mpack_done_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mpack_done_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes reading an extended type binary data blob. </p>
<p >This will track reads to ensure that the correct number of bytes are read.</p>
<dl class="section note"><dt>Note</dt><dd>This requires <a class="el" href="group__config.html#gab1d8587f6e314e491c7fdb262f0b2bd1">MPACK_EXTENSIONS</a>. </dd></dl>

</div>
</div>
<a id="ga86165fc780e7adef09f4b45aee54842a" name="ga86165fc780e7adef09f4b45aee54842a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86165fc780e7adef09f4b45aee54842a">&#9670;&#160;</a></span>mpack_done_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mpack_done_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes reading a map. </p>
<p >This will track reads to ensure that the correct number of elements are read. </p>

</div>
</div>
<a id="gaaad37015e0c53704d9356de06b493de6" name="gaaad37015e0c53704d9356de06b493de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaad37015e0c53704d9356de06b493de6">&#9670;&#160;</a></span>mpack_done_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mpack_done_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes reading a string. </p>
<p >This will track reads to ensure that the correct number of bytes are read. </p>

</div>
</div>
<a id="ga2ec982b75a30187d9f94831f2e4b20a0" name="ga2ec982b75a30187d9f94831f2e4b20a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ec982b75a30187d9f94831f2e4b20a0">&#9670;&#160;</a></span>mpack_done_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_done_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga22f03cf1240d5a917e1b3e7be8ab327e">mpack_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes reading the given type. </p>
<p >This will track reads to ensure that the correct number of elements or bytes are read. </p>

</div>
</div>
<a id="ga397a8d0738b8d68753a470a988b813aa" name="ga397a8d0738b8d68753a470a988b813aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga397a8d0738b8d68753a470a988b813aa">&#9670;&#160;</a></span>mpack_peek_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#ga008da69ac6b5582a893f2d2ffd37f4ac">mpack_tag_t</a> mpack_peek_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the next MessagePack object header (an MPack tag) without advancing the reader. </p>
<p >If an error occurs, the reader is placed in an error state and a nil tag is returned. If the reader is already in an error state, a nil tag is returned.</p>
<dl class="section note"><dt>Note</dt><dd>Maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#ga70c00ecaf381e9711f6c1d0fa92f0c2f" title="Reads a MessagePack object header (an MPack tag.)">mpack_read_tag()</a> </dd>
<dd>
<a class="el" href="group__reader.html#ga438bb2b85fbbd06cd8f10d5c8079427e" title="Reads and discards the next object.">mpack_discard()</a> </dd></dl>

</div>
</div>
<a id="gaeb91e8d4e2a7b7f6562d8bbb7400275c" name="gaeb91e8d4e2a7b7f6562d8bbb7400275c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb91e8d4e2a7b7f6562d8bbb7400275c">&#9670;&#160;</a></span>mpack_read_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_read_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads bytes from a string, binary blob or extension object, copying them into the given buffer. </p>
<p >A str, bin or ext must have been opened by a call to <a class="el" href="group__reader.html#ga70c00ecaf381e9711f6c1d0fa92f0c2f" title="Reads a MessagePack object header (an MPack tag.)">mpack_read_tag()</a> which yielded one of these types, or by a call to an expect function such as <a class="el" href="group__expect.html#ga6baba88194988c9f423630052d59f7fd" title="Reads the start of a string, returning its size in bytes.">mpack_expect_str()</a> or <a class="el" href="group__expect.html#gadcf7fc94ae30ed5c3752291a0efd43c5" title="Reads the start of a binary blob, returning its size in bytes.">mpack_expect_bin()</a>.</p>
<p >If an error occurs, the buffer contents are undefined.</p>
<p >This can be called multiple times for a single str, bin or ext to read the data in chunks. The total data read must add up to the size of the object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The MPack reader </td></tr>
    <tr><td class="paramname">p</td><td>The buffer in which to copy the bytes </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga539b6fe809908faf0f2e030b07efa8d8" name="ga539b6fe809908faf0f2e030b07efa8d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga539b6fe809908faf0f2e030b07efa8d8">&#9670;&#160;</a></span>mpack_read_bytes_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * mpack_read_bytes_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads bytes from a string, binary blob or extension object, allocating storage for them and returning the allocated pointer. </p>
<p >The allocated string must be freed with <a class="el" href="group__config.html#ga298d7c2e4093bcfe361088df9e35956a" title="Defines the memory free function used by MPack.">MPACK_FREE()</a> (or simply free() if MPack's allocator hasn't been customized.)</p>
<p >Returns NULL if any error occurs, or if count is zero. </p>

</div>
</div>
<a id="ga4777ac528d7abbc7313469737546e1a4" name="ga4777ac528d7abbc7313469737546e1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4777ac528d7abbc7313469737546e1a4">&#9670;&#160;</a></span>mpack_read_bytes_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * mpack_read_bytes_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads bytes from a string, binary blob or extension object in-place in the buffer. </p>
<p >This can be used to avoid copying the data.</p>
<p >A str, bin or ext must have been opened by a call to <a class="el" href="group__reader.html#ga70c00ecaf381e9711f6c1d0fa92f0c2f" title="Reads a MessagePack object header (an MPack tag.)">mpack_read_tag()</a> which yielded one of these types, or by a call to an expect function such as <a class="el" href="group__expect.html#ga6baba88194988c9f423630052d59f7fd" title="Reads the start of a string, returning its size in bytes.">mpack_expect_str()</a> or <a class="el" href="group__expect.html#gadcf7fc94ae30ed5c3752291a0efd43c5" title="Reads the start of a binary blob, returning its size in bytes.">mpack_expect_bin()</a>.</p>
<p >If the bytes are from a string, the string is not null-terminated! Use <a class="el" href="group__reader.html#ga628cbed1d2ffac977fed3b9ef5bf0fea" title="Reads bytes from a string, ensures that the string contains no NUL bytes, copies the bytes into the g...">mpack_read_cstr()</a> to copy the string into a buffer and add a null-terminator.</p>
<p >The returned pointer is invalidated on the next read, or when the buffer is destroyed.</p>
<p >The reader will move data around in the buffer if needed to ensure that the pointer can always be returned, so this should only be used if count is very small compared to the buffer size. If you need to check whether a small size is reasonable (for example you intend to handle small and large sizes differently), you can call <a class="el" href="group__reader.html#gaa69e23a50f63c84b45f9247db9c22ad0" title="Returns true if it&#39;s a good idea to read the given number of bytes in-place.">mpack_should_read_bytes_inplace()</a>.</p>
<p >This can be called multiple times for a single str, bin or ext to read the data in chunks. The total data read must add up to the size of the object.</p>
<p >NULL is returned if the reader is in an error state.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_too_big</td><td>if the requested size is larger than the buffer size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#gaa69e23a50f63c84b45f9247db9c22ad0" title="Returns true if it&#39;s a good idea to read the given number of bytes in-place.">mpack_should_read_bytes_inplace()</a> </dd></dl>

</div>
</div>
<a id="ga628cbed1d2ffac977fed3b9ef5bf0fea" name="ga628cbed1d2ffac977fed3b9ef5bf0fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga628cbed1d2ffac977fed3b9ef5bf0fea">&#9670;&#160;</a></span>mpack_read_cstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_read_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byte_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads bytes from a string, ensures that the string contains no NUL bytes, copies the bytes into the given buffer and adds a null-terminator. </p>
<p >A string must have been opened by a call to <a class="el" href="group__reader.html#ga70c00ecaf381e9711f6c1d0fa92f0c2f" title="Reads a MessagePack object header (an MPack tag.)">mpack_read_tag()</a> which yielded a string, or by a call to an expect function such as <a class="el" href="group__expect.html#ga6baba88194988c9f423630052d59f7fd" title="Reads the start of a string, returning its size in bytes.">mpack_expect_str()</a>.</p>
<p >The given byte count must match the size of the string as returned by the tag or expect function. The string will only be copied if the buffer is large enough to store it.</p>
<p >If an error occurs, the buffer will contain an empty string.</p>
<dl class="section note"><dt>Note</dt><dd>If you know the object will be a string before reading it, it is highly recommended to use <a class="el" href="group__expect.html#ga94489d03628c1fb1a3d0ac6971600fe8" title="Reads a string into the given buffer, ensures it has no null bytes, and adds a null-terminator at the...">mpack_expect_cstr()</a> instead. Alternatively you could use <a class="el" href="group__reader.html#ga397a8d0738b8d68753a470a988b813aa" title="Parses the next MessagePack object header (an MPack tag) without advancing the reader.">mpack_peek_tag()</a> and call <a class="el" href="group__expect.html#ga94489d03628c1fb1a3d0ac6971600fe8" title="Reads a string into the given buffer, ensures it has no null bytes, and adds a null-terminator at the...">mpack_expect_cstr()</a> if it's a string.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_too_big</td><td>if the string plus null-terminator is larger than the given buffer size </td></tr>
    <tr><td class="paramname">mpack_error_type</td><td>if the string contains a null byte.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#ga397a8d0738b8d68753a470a988b813aa" title="Parses the next MessagePack object header (an MPack tag) without advancing the reader.">mpack_peek_tag()</a> </dd>
<dd>
<a class="el" href="group__expect.html#ga94489d03628c1fb1a3d0ac6971600fe8" title="Reads a string into the given buffer, ensures it has no null bytes, and adds a null-terminator at the...">mpack_expect_cstr()</a> </dd>
<dd>
<a class="el" href="group__expect.html#ga62be63032f3c84181eeed4609f0dddb4" title="Reads a string into the given buffer, ensures it is a valid UTF-8 string without NUL characters,...">mpack_expect_utf8_cstr()</a> </dd></dl>

</div>
</div>
<a id="ga70c00ecaf381e9711f6c1d0fa92f0c2f" name="ga70c00ecaf381e9711f6c1d0fa92f0c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70c00ecaf381e9711f6c1d0fa92f0c2f">&#9670;&#160;</a></span>mpack_read_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#ga008da69ac6b5582a893f2d2ffd37f4ac">mpack_tag_t</a> mpack_read_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a MessagePack object header (an MPack tag.) </p>
<p >If an error occurs, the reader is placed in an error state and a nil tag is returned. If the reader is already in an error state, a nil tag is returned.</p>
<p >If the type is compound (i.e. is a map, array, string, binary or extension type), additional reads are required to get the contained data, and the corresponding done function must be called when done.</p>
<dl class="section note"><dt>Note</dt><dd>Maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object, copying them into the given buffer.">mpack_read_bytes()</a> </dd>
<dd>
<a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06" title="Finishes reading an array.">mpack_done_array()</a> </dd>
<dd>
<a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a" title="Finishes reading a map.">mpack_done_map()</a> </dd>
<dd>
<a class="el" href="group__reader.html#gaaad37015e0c53704d9356de06b493de6" title="Finishes reading a string.">mpack_done_str()</a> </dd>
<dd>
<a class="el" href="group__reader.html#gaa4676c4b0761de4f864fd81c347a15a0" title="Finishes reading a binary data blob.">mpack_done_bin()</a> </dd>
<dd>
<a class="el" href="group__reader.html#ga5ebed90f6fe9c1d324256d827032702b" title="Finishes reading an extended type binary data blob.">mpack_done_ext()</a> </dd></dl>

</div>
</div>
<a id="gabd0162db0e7e1d0e01a5b5cd1759d1b5" name="gabd0162db0e7e1d0e01a5b5cd1759d1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd0162db0e7e1d0e01a5b5cd1759d1b5">&#9670;&#160;</a></span>mpack_read_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#structmpack__timestamp__t">mpack_timestamp_t</a> mpack_read_timestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a timestamp contained in an ext object of the given size, closing the ext type. </p>
<p >An ext object of exttype <a class="el" href="group__common.html#gaa1d2103131383ae41a543a65bd0929b7">MPACK_EXTTYPE_TIMESTAMP</a> must have been opened by a call to e.g. <a class="el" href="group__reader.html#ga70c00ecaf381e9711f6c1d0fa92f0c2f" title="Reads a MessagePack object header (an MPack tag.)">mpack_read_tag()</a> or <a class="el" href="group__expect.html#ga209c4378b3942b8f76ef69a1de2276cd" title="Reads the start of an extension blob, returning its size in bytes and placing the type into type.">mpack_expect_ext()</a>.</p>
<p >You must NOT call <a class="el" href="group__reader.html#ga5ebed90f6fe9c1d324256d827032702b" title="Finishes reading an extended type binary data blob.">mpack_done_ext()</a> after calling this. A timestamp ext object can only contain a single timestamp value, so this calls <a class="el" href="group__reader.html#ga5ebed90f6fe9c1d324256d827032702b" title="Finishes reading an extended type binary data blob.">mpack_done_ext()</a> automatically.</p>
<dl class="section note"><dt>Note</dt><dd>This requires <a class="el" href="group__config.html#gab1d8587f6e314e491c7fdb262f0b2bd1">MPACK_EXTENSIONS</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_invalid</td><td>if the size is not one of the supported timestamp sizes, or if the nanoseconds are out of range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaee9d5bd9ec3d123dac575651f0ec2186" name="gaee9d5bd9ec3d123dac575651f0ec2186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee9d5bd9ec3d123dac575651f0ec2186">&#9670;&#160;</a></span>mpack_read_utf8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_read_utf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byte_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads bytes from a string, ensures that the string is valid UTF-8, and copies the bytes into the given buffer. </p>
<p >A string must have been opened by a call to <a class="el" href="group__reader.html#ga70c00ecaf381e9711f6c1d0fa92f0c2f" title="Reads a MessagePack object header (an MPack tag.)">mpack_read_tag()</a> which yielded a string, or by a call to an expect function such as <a class="el" href="group__expect.html#ga6baba88194988c9f423630052d59f7fd" title="Reads the start of a string, returning its size in bytes.">mpack_expect_str()</a>.</p>
<p >The given byte count must match the complete size of the string as returned by the tag or expect function. You must ensure that the buffer fits the data.</p>
<p >This does not accept any UTF-8 variant such as Modified UTF-8, CESU-8 or WTF-8. Only pure UTF-8 is allowed.</p>
<p >If an error occurs, the buffer contents are undefined.</p>
<p >Unlike <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object, copying them into the given buffer.">mpack_read_bytes()</a>, this cannot be used to read the data in chunks (since this might split a character's UTF-8 bytes, and the reader does not keep track of the UTF-8 decoding state between reads.)</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the string contains invalid UTF-8. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad053c4bccda721a25c48d66fa0f211cf" name="gad053c4bccda721a25c48d66fa0f211cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad053c4bccda721a25c48d66fa0f211cf">&#9670;&#160;</a></span>mpack_read_utf8_cstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_read_utf8_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byte_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads bytes from a string, ensures that the string is valid UTF-8 with no NUL bytes, copies the bytes into the given buffer and adds a null-terminator. </p>
<p >A string must have been opened by a call to <a class="el" href="group__reader.html#ga70c00ecaf381e9711f6c1d0fa92f0c2f" title="Reads a MessagePack object header (an MPack tag.)">mpack_read_tag()</a> which yielded a string, or by a call to an expect function such as <a class="el" href="group__expect.html#ga6baba88194988c9f423630052d59f7fd" title="Reads the start of a string, returning its size in bytes.">mpack_expect_str()</a>.</p>
<p >The given byte count must match the size of the string as returned by the tag or expect function. The string will only be copied if the buffer is large enough to store it.</p>
<p >This does not accept any UTF-8 variant such as Modified UTF-8, CESU-8 or WTF-8. Only pure UTF-8 is allowed, but without the NUL character, since it cannot be represented in a null-terminated string.</p>
<p >If an error occurs, the buffer will contain an empty string.</p>
<dl class="section note"><dt>Note</dt><dd>If you know the object will be a string before reading it, it is highly recommended to use <a class="el" href="group__expect.html#ga62be63032f3c84181eeed4609f0dddb4" title="Reads a string into the given buffer, ensures it is a valid UTF-8 string without NUL characters,...">mpack_expect_utf8_cstr()</a> instead. Alternatively you could use <a class="el" href="group__reader.html#ga397a8d0738b8d68753a470a988b813aa" title="Parses the next MessagePack object header (an MPack tag) without advancing the reader.">mpack_peek_tag()</a> and call <a class="el" href="group__expect.html#ga62be63032f3c84181eeed4609f0dddb4" title="Reads a string into the given buffer, ensures it is a valid UTF-8 string without NUL characters,...">mpack_expect_utf8_cstr()</a> if it's a string.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_too_big</td><td>if the string plus null-terminator is larger than the given buffer size </td></tr>
    <tr><td class="paramname">mpack_error_type</td><td>if the string contains invalid UTF-8 or a null byte.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#ga397a8d0738b8d68753a470a988b813aa" title="Parses the next MessagePack object header (an MPack tag) without advancing the reader.">mpack_peek_tag()</a> </dd>
<dd>
<a class="el" href="group__expect.html#ga62be63032f3c84181eeed4609f0dddb4" title="Reads a string into the given buffer, ensures it is a valid UTF-8 string without NUL characters,...">mpack_expect_utf8_cstr()</a> </dd></dl>

</div>
</div>
<a id="ga76af5d206358a692b2aeeec6dbeff29c" name="ga76af5d206358a692b2aeeec6dbeff29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76af5d206358a692b2aeeec6dbeff29c">&#9670;&#160;</a></span>mpack_read_utf8_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * mpack_read_utf8_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads bytes from a string in-place in the buffer and ensures they are valid UTF-8. </p>
<p >This can be used to avoid copying the data.</p>
<p >A string must have been opened by a call to <a class="el" href="group__reader.html#ga70c00ecaf381e9711f6c1d0fa92f0c2f" title="Reads a MessagePack object header (an MPack tag.)">mpack_read_tag()</a> which yielded a string, or by a call to an expect function such as <a class="el" href="group__expect.html#ga6baba88194988c9f423630052d59f7fd" title="Reads the start of a string, returning its size in bytes.">mpack_expect_str()</a>.</p>
<p >The string is not null-terminated! Use <a class="el" href="group__reader.html#gad053c4bccda721a25c48d66fa0f211cf" title="Reads bytes from a string, ensures that the string is valid UTF-8 with no NUL bytes,...">mpack_read_utf8_cstr()</a> to copy the string into a buffer and add a null-terminator.</p>
<p >The returned pointer is invalidated on the next read, or when the buffer is destroyed.</p>
<p >The reader will move data around in the buffer if needed to ensure that the pointer can always be returned, so this should only be used if count is very small compared to the buffer size. If you need to check whether a small size is reasonable (for example you intend to handle small and large sizes differently), you can call <a class="el" href="group__reader.html#gaa69e23a50f63c84b45f9247db9c22ad0" title="Returns true if it&#39;s a good idea to read the given number of bytes in-place.">mpack_should_read_bytes_inplace()</a>.</p>
<p >This does not accept any UTF-8 variant such as Modified UTF-8, CESU-8 or WTF-8. Only pure UTF-8 is allowed.</p>
<p >Unlike <a class="el" href="group__reader.html#ga4777ac528d7abbc7313469737546e1a4" title="Reads bytes from a string, binary blob or extension object in-place in the buffer.">mpack_read_bytes_inplace()</a>, this cannot be used to read the data in chunks (since this might split a character's UTF-8 bytes, and the reader does not keep track of the UTF-8 decoding state between reads.)</p>
<p >NULL is returned if the reader is in an error state.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the string contains invalid UTF-8 </td></tr>
    <tr><td class="paramname">mpack_error_too_big</td><td>if the requested size is larger than the buffer size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#gaa69e23a50f63c84b45f9247db9c22ad0" title="Returns true if it&#39;s a good idea to read the given number of bytes in-place.">mpack_should_read_bytes_inplace()</a> </dd></dl>

</div>
</div>
<a id="gaee1c031416ba0ee0d516aeb9e1858fce" name="gaee1c031416ba0ee0d516aeb9e1858fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee1c031416ba0ee0d516aeb9e1858fce">&#9670;&#160;</a></span>mpack_reader_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * mpack_reader_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the custom context for reader callbacks. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#gafc76e77e7431f13ba7ff6a6a83fffe07" title="Sets the custom pointer to pass to the reader callbacks, such as fill or teardown.">mpack_reader_set_context</a> </dd>
<dd>
<a class="el" href="group__reader.html#gaf4eab68e9d1751ff9c6c853d563d9a0e" title="Sets the fill function to refill the data buffer when it runs out of data.">mpack_reader_set_fill</a> </dd>
<dd>
<a class="el" href="group__reader.html#gaa925114414e77ff809fcaaba399c8162" title="Sets the skip function to discard bytes from the source stream.">mpack_reader_set_skip</a> </dd></dl>

</div>
</div>
<a id="gac04666405e21eea6e8819182571f0d20" name="gac04666405e21eea6e8819182571f0d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac04666405e21eea6e8819182571f0d20">&#9670;&#160;</a></span>mpack_reader_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> mpack_reader_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleans up the MPack reader, ensuring that all compound elements have been completely read. </p>
<p >Returns the final error state of the reader.</p>
<p >This will assert in tracking mode if the reader is not in an error state and has any incomplete reads. If you want to cancel reading in the middle of a document, you need to flag an error on the reader before destroying it (such as mpack_error_data).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#ga70c00ecaf381e9711f6c1d0fa92f0c2f" title="Reads a MessagePack object header (an MPack tag.)">mpack_read_tag()</a> </dd>
<dd>
<a class="el" href="group__reader.html#ga5c45c2e0592f16ae671cd509d8d8c512" title="Places the reader in the given error state, calling the error callback if one is set.">mpack_reader_flag_error()</a> </dd>
<dd>
<a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ae53cbed8fcc42915d71ae37d121b22e8" title="The contained data is not valid.">mpack_error_data</a> </dd></dl>

</div>
</div>
<a id="ga79050efd2a581e8216f58d4946e7abc2" name="ga79050efd2a581e8216f58d4946e7abc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79050efd2a581e8216f58d4946e7abc2">&#9670;&#160;</a></span>mpack_reader_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> mpack_reader_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the error state of the MPack reader. </p>
<p >If a reader is in an error state, you should discard all data since the last time the error flag was checked. The error flag cannot be cleared. </p>

</div>
</div>
<a id="ga5c45c2e0592f16ae671cd509d8d8c512" name="ga5c45c2e0592f16ae671cd509d8d8c512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c45c2e0592f16ae671cd509d8d8c512">&#9670;&#160;</a></span>mpack_reader_flag_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_reader_flag_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places the reader in the given error state, calling the error callback if one is set. </p>
<p >This allows you to externally flag errors, for example if you are validating data as you read it.</p>
<p >If the reader is already in an error state, this call is ignored and no error callback is called. </p>

</div>
</div>
<a id="ga09da1e5abbce2b9f7f70d82924eefa3f" name="ga09da1e5abbce2b9f7f70d82924eefa3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09da1e5abbce2b9f7f70d82924eefa3f">&#9670;&#160;</a></span>mpack_reader_flag_if_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> mpack_reader_flag_if_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places the reader in the given error state if the given error is not mpack_ok, returning the resulting error state of the reader. </p>
<p >This allows you to externally flag errors, for example if you are validating data as you read it.</p>
<p >If the given error is mpack_ok or if the reader is already in an error state, this call is ignored and the actual error state of the reader is returned. </p>

</div>
</div>
<a id="ga1d79c00c6c013b879b164c26753b3e83" name="ga1d79c00c6c013b879b164c26753b3e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d79c00c6c013b879b164c26753b3e83">&#9670;&#160;</a></span>mpack_reader_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_reader_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an MPack reader with the given buffer. </p>
<p >The reader does not assume ownership of the buffer, but the buffer must be writeable if a fill function will be used to refill it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The MPack reader. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer with which to read MessagePack data. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes already in the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga18f41d6786155f265769351ef550e331" name="ga18f41d6786155f265769351ef550e331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18f41d6786155f265769351ef550e331">&#9670;&#160;</a></span>mpack_reader_init_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_reader_init_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an MPack reader to parse a pre-loaded contiguous chunk of data. </p>
<p >The reader does not assume ownership of the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The MPack reader. </td></tr>
    <tr><td class="paramname">data</td><td>The data to parse. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes pointed to by data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga729bf4c0a79516e97a65d2e278f336e0" name="ga729bf4c0a79516e97a65d2e278f336e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga729bf4c0a79516e97a65d2e278f336e0">&#9670;&#160;</a></span>mpack_reader_init_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_reader_init_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an MPack reader directly into an error state. </p>
<p >Use this if you are writing a wrapper to <a class="el" href="group__reader.html#ga1d79c00c6c013b879b164c26753b3e83" title="Initializes an MPack reader with the given buffer.">mpack_reader_init()</a> which can fail its setup. </p>

</div>
</div>
<a id="ga957b5be20debe9f3b81b629478bda0f5" name="ga957b5be20debe9f3b81b629478bda0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga957b5be20debe9f3b81b629478bda0f5">&#9670;&#160;</a></span>mpack_reader_init_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_reader_init_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>Renamed to <a class="el" href="group__reader.html#gadf19892a6dd87d86bdd02646528964ff" title="Initializes an MPack reader that reads from a file.">mpack_reader_init_filename()</a>. </dd></dl>

</div>
</div>
<a id="gadf19892a6dd87d86bdd02646528964ff" name="gadf19892a6dd87d86bdd02646528964ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf19892a6dd87d86bdd02646528964ff">&#9670;&#160;</a></span>mpack_reader_init_filename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_reader_init_filename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an MPack reader that reads from a file. </p>
<p >The file will be automatically opened and closed by the reader. </p>

</div>
</div>
<a id="ga97127332a566ac5fd7da541cad50bac4" name="ga97127332a566ac5fd7da541cad50bac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97127332a566ac5fd7da541cad50bac4">&#9670;&#160;</a></span>mpack_reader_init_stdfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_reader_init_stdfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stdfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>close_when_done</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an MPack reader that reads from a libc FILE. </p>
<p >This can be used to read from stdin, or from a file opened separately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The MPack reader. </td></tr>
    <tr><td class="paramname">stdfile</td><td>The FILE. </td></tr>
    <tr><td class="paramname">close_when_done</td><td>If true, fclose() will be called on the FILE when it is no longer needed. If false, the file will not be closed when reading is done.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The reader is buffered. It will read data in advance of parsing it, and it may read more data than it parsed. See <a class="el" href="group__reader.html#ga291a38358bde6992b16edda81f2fcf45" title="Returns bytes left in the reader&#39;s buffer.">mpack_reader_remaining()</a> to access the extra data. </dd></dl>

</div>
</div>
<a id="ga291a38358bde6992b16edda81f2fcf45" name="ga291a38358bde6992b16edda81f2fcf45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga291a38358bde6992b16edda81f2fcf45">&#9670;&#160;</a></span>mpack_reader_remaining()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_reader_remaining </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns bytes left in the reader's buffer. </p>
<p >If you are done reading MessagePack data but there is other interesting data following it, the reader may have buffered too much data. The number of bytes remaining in the buffer and a pointer to the position of those bytes can be queried here.</p>
<p >If you know the length of the MPack chunk beforehand, it's better to instead have your fill function limit the data it reads so that the reader does not have extra data. In this case you can simply check that this returns zero.</p>
<p >Returns 0 if the reader is in an error state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The MPack reader from which to query remaining data. </td></tr>
    <tr><td class="paramname">data</td><td>[out] A pointer to the remaining data, or NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes remaining in the buffer. </dd></dl>

</div>
</div>
<a id="gafc76e77e7431f13ba7ff6a6a83fffe07" name="gafc76e77e7431f13ba7ff6a6a83fffe07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc76e77e7431f13ba7ff6a6a83fffe07">&#9670;&#160;</a></span>mpack_reader_set_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_reader_set_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the custom pointer to pass to the reader callbacks, such as fill or teardown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The MPack reader. </td></tr>
    <tr><td class="paramname">context</td><td>User data to pass to the reader callbacks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#gaee1c031416ba0ee0d516aeb9e1858fce" title="Returns the custom context for reader callbacks.">mpack_reader_context()</a> </dd></dl>

</div>
</div>
<a id="ga926fbc6c3e5d048001dc070c8dc015ed" name="ga926fbc6c3e5d048001dc070c8dc015ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga926fbc6c3e5d048001dc070c8dc015ed">&#9670;&#160;</a></span>mpack_reader_set_error_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_reader_set_error_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__reader.html#ga799a3f21adc8e229c6040ab42d90bef3">mpack_reader_error_t</a>&#160;</td>
          <td class="paramname"><em>error_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the error function to call when an error is flagged on the reader. </p>
<p >This should normally be used with <a class="el" href="group__reader.html#gafc76e77e7431f13ba7ff6a6a83fffe07" title="Sets the custom pointer to pass to the reader callbacks, such as fill or teardown.">mpack_reader_set_context()</a> to register a custom pointer to pass to the error function.</p>
<p >See the definition of mpack_reader_error_t for more information about what you can do from an error callback.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#ga799a3f21adc8e229c6040ab42d90bef3" title="An error handler function to be called when an error is flagged on the reader.">mpack_reader_error_t</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The MPack reader. </td></tr>
    <tr><td class="paramname">error_fn</td><td>The function to call when an error is flagged on the reader. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf4eab68e9d1751ff9c6c853d563d9a0e" name="gaf4eab68e9d1751ff9c6c853d563d9a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4eab68e9d1751ff9c6c853d563d9a0e">&#9670;&#160;</a></span>mpack_reader_set_fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_reader_set_fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__reader.html#ga97503ca06d41d58c60226b2732661eda">mpack_reader_fill_t</a>&#160;</td>
          <td class="paramname"><em>fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the fill function to refill the data buffer when it runs out of data. </p>
<p >If no fill function is used, truncated MessagePack data results in mpack_error_invalid (since the buffer is assumed to contain a complete MessagePack object.)</p>
<p >If a fill function is used, truncated MessagePack data usually results in mpack_error_io (since the fill function fails to get the missing data.)</p>
<p >This should normally be used with <a class="el" href="group__reader.html#gafc76e77e7431f13ba7ff6a6a83fffe07" title="Sets the custom pointer to pass to the reader callbacks, such as fill or teardown.">mpack_reader_set_context()</a> to register a custom pointer to pass to the fill function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The MPack reader. </td></tr>
    <tr><td class="paramname">fill</td><td>The function to fetch additional data into the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa925114414e77ff809fcaaba399c8162" name="gaa925114414e77ff809fcaaba399c8162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa925114414e77ff809fcaaba399c8162">&#9670;&#160;</a></span>mpack_reader_set_skip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_reader_set_skip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__reader.html#ga6a0b236c7befe9cb959dabce15acd23b">mpack_reader_skip_t</a>&#160;</td>
          <td class="paramname"><em>skip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the skip function to discard bytes from the source stream. </p>
<p >It's not necessary to implement this function. If the stream is not seekable, don't set a skip callback. The reader will fall back to using the fill function instead.</p>
<p >This should normally be used with <a class="el" href="group__reader.html#gafc76e77e7431f13ba7ff6a6a83fffe07" title="Sets the custom pointer to pass to the reader callbacks, such as fill or teardown.">mpack_reader_set_context()</a> to register a custom pointer to pass to the skip function.</p>
<p >The skip function is ignored in size-optimized builds to reduce code size. Data will be skipped with the fill function when necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The MPack reader. </td></tr>
    <tr><td class="paramname">skip</td><td>The function to discard bytes from the source stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad04ce10afce7422697d861f46e5aee86" name="gad04ce10afce7422697d861f46e5aee86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad04ce10afce7422697d861f46e5aee86">&#9670;&#160;</a></span>mpack_reader_set_teardown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_reader_set_teardown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__reader.html#gadda6baaccdcf0ad9c5e212be9992cf5b">mpack_reader_teardown_t</a>&#160;</td>
          <td class="paramname"><em>teardown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the teardown function to call when the reader is destroyed. </p>
<p >This should normally be used with <a class="el" href="group__reader.html#gafc76e77e7431f13ba7ff6a6a83fffe07" title="Sets the custom pointer to pass to the reader callbacks, such as fill or teardown.">mpack_reader_set_context()</a> to register a custom pointer to pass to the teardown function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The MPack reader. </td></tr>
    <tr><td class="paramname">teardown</td><td>The function to call when the reader is destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa69e23a50f63c84b45f9247db9c22ad0" name="gaa69e23a50f63c84b45f9247db9c22ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa69e23a50f63c84b45f9247db9c22ad0">&#9670;&#160;</a></span>mpack_should_read_bytes_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_should_read_bytes_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if it's a good idea to read the given number of bytes in-place. </p>
<p >If the read will be larger than some small fraction of the buffer size, this will return false to avoid shuffling too much data back and forth in the buffer.</p>
<p >Use this if you're expecting arbitrary size data, and you want to read in-place for the best performance when possible but will fall back to a normal read if the data is too large.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#ga4777ac528d7abbc7313469737546e1a4" title="Reads bytes from a string, binary blob or extension object in-place in the buffer.">mpack_read_bytes_inplace()</a> </dd></dl>

</div>
</div>
<a id="ga0c7e1dd2be56ce3d596326c4463e7229" name="ga0c7e1dd2be56ce3d596326c4463e7229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c7e1dd2be56ce3d596326c4463e7229">&#9670;&#160;</a></span>mpack_skip_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_skip_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skips bytes from the underlying stream. </p>
<p >This is used only to skip the contents of a string, binary blob or extension object. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
